#!/usr/bin/env bash

# Default parameters
singleline=1
out=0
threads=1
name_sort=0
reverse_sort=0
length_sort=0
lettercase=0
complement=0
rev_seq=0
orf=0
frame=1
translate=0
min_prot=0
translate_table=1
percent_GC=0
verbose=0
help=0

print_usage(){
 printf "
fastakit [OPTIONS] FASTA_file.fasta
	-o | --out	Output to file (otherwise to stdout)
	-n | --name_sort	Sort FASTA by name
	-s | --length_sort	Sort FASTA by sequence length (shortest to longest)
	-r | --reverse_sort	Sort in reverse order
	-u | --upper	Sequences to uppercase
	-l | --lower	Sequences to lowercase
	-c | --complement	Complementary sequence
	-m | --reverse_seq	Reverse sequence
	-g | --orf	Sequence from first ATG in frame (Default frame 1)
	-p | --translate	Protein sequences in current frame (Default frame 1)
	-a | --table	Translation code (Default standard code)
	-f | --frame	Frame to extract codons (must be 1, 2 or 3)
	-e | --min_prot #	Minimum protein size (assumes --translate)
	-t | --threads #	Number of CPU threads to use (Default = 1)
	-d | --gc	Get percent GC per sequence (turns off --translate)
	-v | --verbose	Verbose
	-h | --help	Display help
	--skip_singleline	Skip changing multi-line FASTA to single-line FASTA 
	--available_codes	Show available translation codes

"
}

# Error function
error_exit(){
	echo "$1" 1>&2
	exit 1
}

# Alternative tables
tables(){
printf "
	Available translation codes:
	1 - Standard code
	2 - Vertebrate Mitochondrial code
	3 - Yeast mitochondrial code
	4 - Mold, protozoan, and coelenterate mitochondrial code and the mycoplasma/spiroplasma code

"
}

# Check arguments
for arg in "$@"
do
 case $arg in
  -o | --out)
  out=1 # Output to file
  shift
  outfile=$1
  shift
  ;;
  -n | --name_sort)
  name_sort=1 # Sort FASTA file by name
  shift
  ;;
  -s | --length_sort)
  length_sort=1 # Sort FASTA file by sequence length
  shift
  ;;
  -r | --reverse_sort)
  reverse_sort=1 # Sort in reverse order
  shift
  ;;
  -u | --upper)
  lettercase=1 # Sequences to uppercase
  shift
  ;;
  -l | --lower)
  lettercase=2 # Sequences to lowercase
  shift
  ;;
  -c | --complement)
  complement=1 # Complementary sequences
  shift
  ;;
  -m | --reverse_seq)
  rev_seq=1 # Reverse sequences
  shift
  ;;
  -f | --frame)
  shift # Set frame for codons
  frame=$1
  shift
  ;;
  -g | --orf)
  orf=1 # Sequence from first ATG in frame
  shift
  ;;
  -p | --translate)
  translate=1 # Translate sequences
  shift
  ;;
  -d | --gc)
  percent_GC=1 # Get percent GC per sequence
  shift
  ;;
  -a | --table)
  shift
  translate_table=$1 # Alternative translation table
  shift
  ;;
  --skip_singleline)
  singleline=0 # Skip single-line conversion
  shift
  ;;
  --available_codes)
  tables
  exit 0
  ;;
  -e | --min_prot)
  min_prot=1 # Minimum protein size
  translate=1 # Translate sequences
  shift
  min_prot_length=$1
  shift
  ;;
  -t | --threads)
  shift
  threads=$1 # Number of CPU threads
  shift
  ;;
  -v | --verbose)
  verbose=1 # Print file names and arguments
  shift
  ;;
  -h | --help)
  print_usage
  exit 1
  ;;
  *)
  esac
  done
  
  # Translation functions
  # Standard code
  if [[ $translate_table = 1 ]]
  then
  translate(){
	while read seq; do \
	echo $seq |
	awk '{print tolower($0)}' |
	sed --regexp-extended \
     's/atg/M/g;
      s/at[tca]/I/g;
      s/ac[actg]/T/g;
      s/aa[tc]/N/g;
      s/aa[ag]/K/g;
      s/ag[tc]/S/g;
      s/ag[ag]/R/g;
      s/tt[tc]/F/g;
      s/tt[ag]/L/g;
      s/tc[acgt]/S/g;
      s/ta[tc]/Y/g;
      s/ta[ag]/*/g;
      s/tg[tc]/C/g;
      s/tga/*/g;
      s/tgg/W/g;
      s/ct[acgt]/L/g;
      s/cc[acgt]/P/g;
      s/ca[tc]/H/g;
      s/ca[ag]/Q/g;
      s/cg[acgt]/R/g;
      s/gt[acgt]/V/g;
      s/gc[acgt]/A/g;
      s/ga[tc]/D/g;
      s/ga[ag]/E/g;
      s/gg[acgt]/G/g' \
      ;done
}
  fi
  
  # Vertebrate mitochondrial code
  if [[ $translate_table = 2 ]]
  then
  translate(){
	while read seq; do \
	echo $seq |
	awk '{print tolower($0)}' |
	sed --regexp-extended \
     's/at[ag]/M/g;
      s/at[tc]/I/g;
      s/ac[actg]/T/g;
      s/aa[tc]/N/g;
      s/aa[ag]/K/g;
      s/ag[tc]/S/g;
      s/ag[ag]/*/g;
      s/tt[tc]/F/g;
      s/tt[ag]/L/g;
      s/tc[acgt]/S/g;
      s/ta[tc]/Y/g;
      s/ta[ag]/*/g;
      s/tg[tc]/C/g;
      s/tg[ag]/W/g;
      s/ct[acgt]/L/g;
      s/cc[acgt]/P/g;
      s/ca[tc]/H/g;
      s/ca[ag]/Q/g;
      s/cg[acgt]/R/g;
      s/gt[acgt]/V/g;
      s/gc[acgt]/A/g;
      s/ga[tc]/D/g;
      s/ga[ag]/E/g;
      s/gg[acgt]/G/g' \
      ;done
}
  fi

  # Yeast mitochondrial code
  if [[ $translate_table = 3 ]]
  then
  translate(){
	while read seq; do \
	echo $seq |
	awk '{print tolower($0)}' |
	sed --regexp-extended \
     's/at[ag]/M/g;
      s/at[tc]/I/g;
      s/ac[actg]/T/g;
      s/aa[tc]/N/g;
      s/aa[ag]/K/g;
      s/ag[tc]/S/g;
      s/ag[ag]/R/g;
      s/tt[tc]/F/g;
      s/tt[ag]/L/g;
      s/tc[acgt]/S/g;
      s/ta[tc]/Y/g;
      s/ta[ag]/*/g;
      s/tg[tc]/C/g;
      s/tg[ag]/W/g;
      s/ct[acgt]/T/g;
      s/cc[acgt]/P/g;
      s/ca[tc]/H/g;
      s/ca[ag]/Q/g;
      s/cg[gt]/R/g;
      s/gt[acgt]/V/g;
      s/gc[acgt]/A/g;
      s/ga[tc]/D/g;
      s/ga[ag]/E/g;
      s/gg[acgt]/G/g;
      s/cg[ac]/X/g' \
      ;done
}
  fi
  
  # Mold, protozoan, and coelenterate mitochondrial code and the mycoplasma/spiroplasma code
  if [[ $translate_table = 4 ]]
  then
  translate(){
	while read seq; do \
	echo $seq |
	awk '{print tolower($0)}' |
	sed --regexp-extended \
     's/atg/M/g;
      s/at[tca]/I/g;
      s/ac[actg]/T/g;
      s/aa[tc]/N/g;
      s/aa[ag]/K/g;
      s/ag[tc]/S/g;
      s/ag[ag]/R/g;
      s/tt[tc]/F/g;
      s/tt[ag]/L/g;
      s/tc[acgt]/S/g;
      s/ta[tc]/Y/g;
      s/ta[ag]/*/g;
      s/tg[tc]/C/g;
      s/tg[ag]/W/g;
      s/ct[acgt]/L/g;
      s/cc[acgt]/P/g;
      s/ca[tc]/H/g;
      s/ca[ag]/Q/g;
      s/cg[acgt]/R/g;
      s/gt[acgt]/V/g;
      s/gc[acgt]/A/g;
      s/ga[tc]/D/g;
      s/ga[ag]/E/g;
      s/gg[acgt]/G/g' \
      ;done
}
  fi
  
  # Frame exception
  if [[ $frame < 1 || $frame > 3 ]]
  then
   echo "Frame value must be 1, 2 or 3"
   print_usage
   exit 1
  fi
  
  # Table exception
  if [[ $translate_table < 1 || $translate_table > 4 ]]
  then
   echo "Error: Unknown translation code"
   tables
   exit 1
  fi
  
  if [[ $percent_GC = 1 ]]
  then
   translate=0
  fi
  
  # Verbose output
    if [[ $verbose = 1 ]]
    then
    if [[ $singleline = 1 ]]; then echo "Write in single-line FASTA"; fi
    if [[ $name_sort = 1 ]]; then echo "Sort by name"; fi
    if [[ $length_sort = 1 ]]; then echo "Sort by length"; fi
    if [[ $reverse_sort = 1 ]]; then echo "Sort in reverse order"; fi
    if [[ $lettercase = 1 ]]; then echo "Change to UPPERCASE"; fi
    if [[ $lettercase = 2 ]]; then echo "Change to lowercase"; fi
    if [[ $complement = 1 ]]; then echo "Change to complement sequence"; fi
    if [[ $rev_seq = 1 ]]; then echo "Change to reverse sequence"; fi
    if [[ $orf = 1 ]]; then echo "ORF | frame "$frame; fi
    if [[ $translate = 1 ]]; then echo "Translate | frame "$frame; fi
    if [[ $translate_table != 1 ]]; then echo "Translation code: "$translate_table; fi
    if [[ $min_prot = 1 ]]; then echo "Minimum protein length: "$min_prot_length; fi
    if [[ $percent_GC = 1 ]]; then echo "Percent GC"; fi
    if [[ $out = 1 ]]; then echo $(basename $file)" ---> "$outfile; fi
    fi
    
    # Create temp files
    HEADERS=$(mktemp)
    TMPFILE1=$(mktemp)
    TMPFILE2=$(mktemp)
    
    # Read from file or stdin
    while read input
     do
      echo "$input"
     done < "${1:-/dev/stdin}" |
     sed --regexp-extended 's/\r//g' > $TMPFILE2
     grep --perl-regexp "^>" $TMPFILE2 > $HEADERS
    
    # Create single line FASTA and change to specified case
    if [[ $singleline = 1 ]]
    then
    echo "Converting to single line FASTA..."
    if [[ $lettercase = 0 ]]
    then
     awk '/^>/ {printf((N>0?"\n":""));N++;next;} {printf("%s",$0);}  END {printf("\n");}' $TMPFILE2
    
    # Convert to upper-case
    elif [[ $lettercase = 1 ]]
     then
      awk '/^>/ {printf((N>0?"\n":""));N++;next;} {printf("%s",toupper($0));}  END {printf("\n");}' $TMPFILE2

    # Convert to lower-case
     elif [[ $lettercase = 2 ]]
      then
       awk '/^>/ {printf((N>0?"\n":""));N++;next;} {printf("%s",tolower($0));}  END {printf("\n");}' $TMPFILE2
    fi > $TMPFILE1
    
    else
     grep --perl-regexp --invert-match "^>" $TMPFILE2 > $TMPFILE1
    fi
     
     # Get complementary sequences
     if [[ $complement = 1 ]]
     then
     echo "Converting to complement sequence..."
      cat $TMPFILE1 |
      tr \"ATCGatcg\" \"TAGCtagc\" > $TMPFILE2
      cp --force $TMPFILE2 $TMPFILE1
     fi
     
     # Get reverse sequences
     if [[ $rev_seq = 1 ]]
     then
     echo "Converting to reverse sequence..."
      rev $TMPFILE1 > $TMPFILE2
      cp --force $TMPFILE2 $TMPFILE1
     fi
     
     # Change frame
     if [[ $frame != 1 ]]
     then
      sed --in-place --regexp-extended 's/^.{'"$(($frame - 1))"'}//g' $TMPFILE1
     fi
     
     # Get sequence ORFs
     if [[ $orf = 1 ]]
     then
     get_orfs(){
     
     orf_num=1
     local ORFstart=$1
     local ORFend=$2
     local orf_core=$3
     local ORFFILE1=$(mktemp)
     local ORFFILE2=$(mktemp)
     local ORFFILE3=$(mktemp)
     local ORFHEADERS=$(mktemp)
     local ORFHEADERS2=$(mktemp)
     
     if [[ $threads != 1 ]]
     then
      sed --quiet ''"$ORFstart"','"$ORFend"'p;'"$(($ORFend + 1))"'q' $TMPFILE1 > $ORFFILE1
      sed --quiet ''"$ORFstart"','"$ORFend"'p;'"$(($ORFend + 1))"'q' $HEADERS > $ORFHEADERS
     else
      cp --force $TMPFILE1 $ORFFILE1
      cp --force $HEADERS $ORFHEADERS
     fi
     
      # Separate codons and cut to first start and stop codon
      local orf_num=1
      if [[ $(($orf_num % 5)) = 0 ]]
       then
        local core_arr=($(cat $core_ORF))
        core_arr[$orf_core]="(core:"$orf_core")="$orf_num
        echo ${core_arr[@]} > $core_ORF
        echo -ne "Extracting ORF "$(cat $core_ORF)"\r"
      fi
      awk -F '' '{for(i=1; i<=NF; i+=3) {printf "%s%s ", $i,$(i+1)$(i+2);}; print ""}' $ORFFILE1 |
      awk -F $'\t' '{if(match(tolower($0),"atg") > 0) print substr($0,match(tolower($0),"atg"));
      if(match(tolower($0),"atg") == 0) print ""}' |
      tee $ORFFILE3 |
      awk -F $'\t' '{if(match(tolower($0),"ta[ag]|tga") > 0) print substr($0,1,match(tolower($0),"ta[ag]|tga")+2);
      if(match(tolower($0),"ta[ag]|tga") == 0) print $0}' |
      if [[ $translate = 1 ]]
      then
       translate |
       sed --regexp-extended 's/[atcg]{1,}$//g' |
       tr -d " " |
       if [[ $min_prot = 1 ]]
       then
        awk -v min_prot_length="$min_prot_length" '{if(match($0,"*|$") - 1 >= min_prot_length) print $0;
        if(match($0,"*|$") - 1 < min_prot_length) print ""}'
       else
        tr -d " "
       fi
      fi > $ORFFILE2
      awk -F $'\t' -v orf_num="$orf_num" '{print $0"_orf"orf_num}' $ORFHEADERS >> $ORFHEADERS2
      cp --force $ORFFILE3 $ORFFILE1

      # Loop over other ORFs
      while [[ $(grep --ignore-case --count "atg" $ORFFILE1) != 0 ]]
      do
      
       orf_num=$(($orf_num + 1))
       
       if [[ $(($orf_num % 5)) = 0 ]]
       then
        local core_arr=($(cat $core_ORF))
        core_arr[$orf_core]="(core:"$orf_core")="$orf_num
        echo ${core_arr[@]} > $core_ORF
        echo -ne "Extracting ORF "$(cat $core_ORF)"\r"
      fi
       : > $ORFFILE3
       
       # Cut until first start and stop codon or until end of line
       awk -F $'\t' '{if(match(tolower($0),"ta[ag]|tga") > 0) print substr($0,match(tolower($0),"ta[ag]|tga")+4);
       if(match(tolower($0),"ta[ag]|tga") == 0) print ""}' $ORFFILE1 |
       tee $ORFFILE3 |
       awk -F $'\t' '{if(match(tolower($0),"atg") > 0) print substr($0,match(tolower($0),"atg"));
       if(match(tolower($0),"atg") == 0) print ""}' |
       awk -F $'\t' '{if(match(tolower($0),"ta[ag]|tga") > 0) print substr($0,1,match(tolower($0),"ta[ag]|tga")+2);
       if(match(tolower($0),"ta[ag]|tga") == 0) print ""}' |
       if [[ $translate = 1 ]]
       then
        translate |
        sed --regexp-extended 's/[atcg]{1,}$//g' |
        tr -d " " |
        if [[ $min_prot = 1 ]]
        then
         awk -v min_prot_length="$min_prot_length" '{if(match($0,"*|$") - 1 >= min_prot_length) print $0;
         if(match($0,"*|$") - 1 < min_prot_length) print ""}'
        else
         tr -d " "
        fi
       fi >> $ORFFILE2
       awk -F $'\t' -v orf_num="$orf_num" '{print $0"_orf"orf_num}' $ORFHEADERS >> $ORFHEADERS2
       cp --force $ORFFILE3 $ORFFILE1
       
      done

      # local index=($(grep --line-number --invert-match --perl-regexp "^$" $ORFFILE2 | cut -d : -f 1 | tr "\n" " "))
      # for ((k=0;k<=${#index[@]} - 1;k++))
      # do
      #  sed --quiet ''"${index[$k]}"'p' $ORFHEADERS >> $HEADERS_TMP
      #  sed --quiet ''"${index[$k]}"'p' $ORFFILE2 >> $TMPFILE2
      # done
      
      cp --force $ORFHEADERS2 $HEADERS_TMP
      cp --force $ORFFILE2 $TMPFILE2
      
      # Cleanup
      rm --force $ORFFILE1
      rm --force $ORFFILE2
      rm --force $ORFFILE3
      rm --force $ORFHEADERS
      rm --force $ORFHEADERS2
     }
     
     # Allocate sequences to requested threads
     seq_num=$(grep --count ">" $HEADERS)
     if [[ $seq_num -lt $threads ]]
     then
      threads=$seq_num
     fi
     
     # Setup start and end lines for dividing sequences
     BATCH=$(( seq_num / $threads ))
     remainder=$(( seq_num % $threads ))
     
     start=1
     end=()
     for ((core=0;core <= $(($threads - 1));core++))
     do
      if [[ ${#end[@]} != 0 ]]
      then
       start=(${start[@]} $((${end[$(($core - 1))]} + 1)))
      fi
      if [[ $core -lt $remainder ]]
      then
       end=(${end[@]} $((${start[$core]} + $BATCH)))
      else
       end=(${end[@]} $((${start[$core]} + $BATCH - 1)))
      fi
     done
     
     # Loop for function getting ORFs for multithreading
     echo "Using "$threads" threads..."
     core_ORF=$(mktemp)
     HEADERS_TMP=$(mktemp)
     : > $TMPFILE2
     for ((core=0;core <= $(($threads - 1));core++))
     do
      get_orfs ${start[$core]} ${end[$core]} $core &
      pids[$core]=$!
     done
     
     for pid in ${pids[*]}
     do
      wait $pid
     done
     echo ""
     cp --force $HEADERS_TMP $HEADERS
     cp --force $TMPFILE2 $TMPFILE1
     rm --force $core_ORF
     rm --force $HEADERS_TMP
    fi
    
    if [[ $translate = 1 && $orf = 0 ]]
    then
    echo "Translating..."
    # Separate to codons and translate
      awk -F '' '{for(i=1; i<=NF; i+=3) {printf "%s%s ", $i,$(i+1)$(i+2);}; print ""}' $TMPFILE1 |
      translate |
       sed --regexp-extended 's/[atcg]{1,}$//g' |
       tr -d " " |
       
       # remove if less than cutoff
       if [[ $min_prot = 1 ]]
       then
        awk -v min_prot_length="$min_prot_length" '{if(match($0,"*|$") - 1 >= min_prot_length) print $0;
        if(match($0,"*|$") - 1 < min_prot_length) print ""}'
       else
        cat
       fi > $TMPFILE2
      cp --force $TMPFILE2 $TMPFILE1
    fi
    
     # GC content
     if [[ $percent_GC = 1 ]]
     then
     echo "Calculating %GC..."
      awk '{var=length($0);gsub("[AaTt]","",$0);print length($0)/var*100}' $TMPFILE1
      exit 0
     fi
     
     paste $HEADERS $TMPFILE1 | grep --perl-regexp --invert-match "\t$" > $TMPFILE2
     cp --force $TMPFILE2 $TMPFILE1
     
     # Sort by name
     if [[ $name_sort = 1 ]]
     then
     echo "Sorting by name..."
      if [[ $reverse_sort = 1 ]]
      then
       sort --reverse --field-separator=$'\t' --key=1 $TMPFILE1 > $TMPFILE2
      else
       sort --field-separator=$'\t' --key=1 $TMPFILE1 > $TMPFILE2
      fi
      cp --force $TMPFILE2 $TMPFILE1
     fi
    
    # Sort by sequence length
     if [[ $length_sort = 1 ]]
     then
     echo "Sorting by length..."
      awk '{print length, $0}' $TMPFILE1 |
      if [[ $reverse_sort = 1 ]]
      then
       sort --numeric-sort --reverse
      else
       sort --numeric-sort
      fi |
      cut --delimiter=" " --fields=2- > $TMPFILE2
      cp --force $TMPFILE2 $TMPFILE1
     fi
     
     # Convert tabbed to FASTA and remove empty headers
     cat $TMPFILE1 |
     tr "\t" "\n" > $TMPFILE2
     cp --force $TMPFILE2 $TMPFILE1
     
        
    # Output to file or stdout
    if [[ $out = 1 ]]
    then
     cp --force $TMPFILE1 $outfile
    else
     cat $TMPFILE1
    fi
    
    rm --force $TMPFILE1
    rm --force $TMPFILE2
    rm --force $HEADERS
