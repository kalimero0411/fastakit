#!/usr/bin/env bash
set -e

# Default parameters
version=24.06
fastakit_dir=$(dirname $(readlink --canonicalize $(which fastakit)))
time_start=$(date +%s)
threads=$(command -v nproc --all &> /dev/null && nproc || echo 1)
lettercase=0
frame=1
translate_table=1
max_orf_num=0

# Cleanup temp files
tmpdir=$(mktemp --tmpdir=/tmp --directory fastakit.XXXXXXXXXX)
chmod --recursive 775 $tmpdir
cleanup(){
 rm --force --recursive $tmpdir
}
trap cleanup EXIT

usage="
Usage: fastakit [OPTION]... [Sequence.fasta]\n
\n\
    -i | --in-place\t Modify file in-place
    -c | --complement\t Complementary sequence
    -m | --reverse_seq\t Reverse sequence
    --unique\t Remove duplicate sequences
    --multi \t Convert to multi-line FASTA (nucleotide only)
    --random\t Create random sequences of respective length
    -n | --name_sort\t Sort FASTA by name
    -l | --length_sort\t Sort FASTA by sequence length (shortest to longest)
    -r | --reverse_sort\t Sort in reverse order
    --upper\t Sequences to UPPERCASE
    --lower\t Sequences to lowercase
    -o | --orf\t Retrieve ORFs
    --max_orf_num #\t Maximum number of ORFs to output per sequence
    -p | --translate\t Protein sequences in current frame
    --table #\t Translation code (Default = standard code; '--table list' for all available codes)
    --frame #\t Frame to extract codons (Any of frames 1,2,3,4,5,6; 0 = six frames; Default = 1)
    --gc\t Calculate percent GC per sequence (Disables --translate)
    --mw\t Calculate the moleculare weight of DNA/RNA/protein per sequence (ss ds)
    --mw_sort\t Sort by molecular weight
    --separate [DIR]\t Separate sequnces into files in directory DIR
    --nonnuc\t Count non-ACTGU characters per sequence
    --rna_dna\t Convert RNA to DNA / DNA to RNA (Default = no conversion)
    --seq_range ,#\t Minimum/Maximum sequence size (e.g. 10,50 ; 0 to ignore)
    --max_seq #\t Return the # of largest sequences for each input sequence (ORFs, proteins, etc.)
    --name_regex [string]\t Truncate FASTA header with regex (used with --max_seq)
    --get_names [string]\t Return the sequences with names that match a string (perl regex)
    --check\t Check if FASTA file is single line
    --makeanno [string]\t Create BED/GFF/GTF output for ORFs (Defaults to --orf and BED format; Default sort by start position)
    --upstream #\t Retrieve # size upstream flanking sequence of ORFs (Assumes --orf)
    --downstream #\t Retrieve # size downstream flanking sequence of ORFs (Assumes --orf)
    --detect\t Detect molucule and exit
    --rename [string]\t Change all sequence names to {string}_ (e.g. '--rename test', will give '>test1' etc.)
    --extract\t Extract contiguous sequences from each sequence (1 = lowercase; 2 = UPPERCASE)
    --re [string],,#,#,#\t Detect restriction enzyme recognition sites\n\t (Restriction enzyme name, min_length, max_length, min_number, max_number; 0 to ignore; 'list' to list all enzymes)
    --stats\t Calculate basic stats
    --version\t Print version date
    -t | --threads #\t Number of CPU threads to use (Default = Detected processors or 1)
    -v | --verbose\t Verbose
    -h | --help\t Display help

Example: fastakit --orf --frame 0 --seq_range 100,1000 --length-sort sequences.fasta > orfs.fasta

" 

# Check arguments
while [ "$#" -gt 0 ]
do
arg=$1
 case $arg in
  -i | --in-place)
  inplace=1 # Modify file in-place
  shift
  ;;
  --unique)
  unique=1 # Remove duplicate sequences
  shift
  ;;
  -n | --name_sort)
  name_sort=1 # Sort FASTA file by name
  shift
  ;;
  --random)
  random=1 # Sort FASTA file by name
  shift
  ;;
  -l | --length_sort)
  length_sort=1 # Sort FASTA file by sequence length
  shift
  ;;
  -r | --reverse_sort)
  reverse_sort=1 # Sort in reverse order
  shift
  ;;
  --upper)
  lettercase=1 # Sequences to uppercase
  shift
  ;;
  --lower)
  lettercase=2 # Sequences to lowercase
  shift
  ;;
  -c | --complement)
  complement=1 # Complementary sequences
  shift
  ;;
  -m | --reverse_seq)
  rev_seq=1 # Reverse sequences
  shift
  ;;
  --frame) # Set frame for codons
  frame=($(echo "$2" | tr "," " "))
  shift 2
  ;;
  -o | --orf)
  orf=1 # Sequence from first ATG in frame
  shift
  ;;
  --max_orf_num)
  max_orf_num=$2 # Maximum number of ORFs per sequence
  shift 2
  ;;
  -p | --translate)
  translate=1 # Translate sequences
  shift
  ;;
  --gc)
  percent_GC=1 # Get percent GC per sequence
  shift
  ;;
  --rna_dna)
  rna_dna=1 # Convert RNA to DNA / DNA to RNA
  shift
  ;;
  --nonnuc)
  nonnuc=1 # Count non-ACTGU characters
  shift
  ;;
  --separate)
  separate=$2 # Separate sequnces into files
  shift 2
  ;;
  --extract)
  extract=$2 # Extract contiguous sequences from each sequence
  shift 2
  ;;
  --table)
  translate_table=$2 # Alternative translation table
  tables=(1 2 3 4 5 6 9 10 11 12 13 14 16 21 22 23 24 25 26 27 28 29 30 31 33)

  if [[ ! "${IFS}${table[*]}${IFS}" =~ "${IFS}$translate_table${IFS}" ]]
  then
   printf "
    Available translation codes:
    
    1 - Standard Code
    2 - Vertebrate Mitochondrial Code
    3 - Yeast mitochondrial Code
    4 - Mold, protozoan, and coelenterate mitochondrial code and the mycoplasma/spiroplasma code
    5 - Invertebrate Mitochondrial Code
    6 - Ciliate, Dasycladacean and Hexamita Nuclear Code
    9 - Echinoderm and Flatworm Mitochondrial Code
    10 - Euplotid Nuclear Code
    11 - Bacterial, Archaeal and Plant Plastid Code
    12 - Alternative Yeast Nuclear Code
    13 - Ascidian Mitochondrial Code
    14 - Alternative Flatworm Mitochondrial Code
    16 - Chlorophycean Mitochondrial Code
    21 - Trematode Mitochondrial Code
    22 - Scenedesmus obliquus Mitochondrial Code
    23 - Thraustochytrium Mitochondrial Code
    24 - Rhabdopleuridae Mitochondrial Code
    25 - Candidate Division SR1 and Gracilibacteria Code
    26 - Pachysolen tannophilus Nuclear Code
    27 - Karyorelict Nuclear Code
    28 - Condylostoma Nuclear Code
    29 - Mesodinium Nuclear Code
    30 - Peritrich Nuclear Code
    31 - Blastocrithidia Nuclear Code
    33 - Cephalodiscidae Mitochondrial UAA-Tyr Code
    
"
   exit 1
  fi
  shift 2
  ;;
  --max_seq)
  max_seq=$2 # Return # of largest proteins
  shift 2
  ;;
  --name_regex)
  name_regex=$2 # Regex for subsetting names (e.g. transcripts to genes)
  shift 2
  ;;
  --get_names)
  get_names=$2 # Regex for retrieving names
  shift 2
  ;;
  --version)
  echo "fastakit version "$version >&2
  exit 0
  ;;
  --check)
  check_sl=1
  shift
  ;;
  --detect)
  detect=1
  shift
  ;;
  --rename)
  rename=$2
  shift 2
  ;;
  --seq_range)
  OFS=$IFS
  IFS=","
  seq_range=($(echo "$2")) # Minimum/Maximum nucleotide sequence size
  IFS=$OFS
  if [ ${seq_range[0]} -eq 0 ] && [ ${seq_range[1]} -eq 0 ]
  then
   unset seq_range
  fi
  shift 2
  ;;
  -t | --threads)
  threads=$2 # Number of CPU threads
  shift 2
  ;;
  --stats)
  stats=1 # Calculate basic stats
  shift
  ;;
  --multi)
  multi=$2 # Covert to multiline FASTA
  shift 2
  ;;
  --makeanno)
  makeanno=$2
  shift 2
  ;;
  --upstream)
  upstream=$2
  shift 2
  ;;
  --downstream)
  downstream=$2
  shift 2
  ;;
  --mw)
  MW=1
  shift
  ;;
  --mw_sort)
  MW_sort=1
  shift
  ;;
  --re)
  renz=1
  min_max_re=($(echo "$2" | tr "," " ")) # Minimum/Maximum re length/number
  shift 2
  ;;
  -v | --verbose)
  verbose=1 # Print file names and arguments
  shift
  ;;
  -h | --help)
  printf "$usage" |
  awk -F $'\t' '{ printf "%-30s %s\n", $1, $2 }'
  exit 0
  ;;
  *)
  if [ -f "$1" ] || [ -p "/dev/fd/${1#/dev/fd/}" ]
  then
   break
  else
  echo "Unknown option: "$1
  printf "$usage" |
  awk -F $'\t' '{ printf "%-30s %s\n", $1, $2 }'
  exit 1
  fi
  ;;
  esac
  done
  
  # Check dependencies
  if ! command -v gawk &> /dev/null
  then
   echo "gawk not installed" >&2
   deps+="gawk "
  fi
  
  if ! command -v perl &> /dev/null
  then
   echo "perl not installed" >&2
   deps+="perl "
  fi
  
  if ! command -v parallel &> /dev/null
  then
   echo "parallel not installed" >&2
   deps+="parallel "
  fi
  
  if [ ! -z ${deps+x} ]
  then
   echo "Install using: sudo apt install "${deps[@]} >&2
   exit 1
  fi
  
  # Time function
  function show_time(){
    num=$(($(date +%s) - time_start))
    min=0
    hour=0
    day=0
    if((num>59));then
        ((sec=num%60))
        ((num=num/60))
        if((num>59));then
            ((min=num%60))
            ((num=num/60))
            if((num>23));then
                ((hour=num%24))
                ((day=num/24))
            else
                ((hour=num))
            fi || true
        else
            ((min=num))
        fi || true
    else
        ((sec=num))
    fi || true
    echo -e "$day"d "$hour"h "$min"m "$sec"s"\n" >&2
}

  # Translation function
  function translate(){
	input=$1 &&
	cat $input |
	
	 # Standard code
	 if [[ $translate_table = 1 ]]
	 then
	  cat
         
         # Vertebrate mitochondrial code
         elif [[ $translate_table = 2 ]]
         then
          sed --regexp-extended \
           's/a[tu]a/M/gi;
            s/ag[ag]/*/gi;
            s/cg[ac]/R/gi;
            s/[tu]ga/W/gi'
       
         # Yeast mitochondrial code
         elif [[ $translate_table = 3 ]]
          then
          sed --regexp-extended \
           's/a[tu]a/M/gi;
            s/c[tu][acgtun]/T/gi;
            s/[tu]ga/W/gi'
       
         # Mold, protozoan, and coelenterate mitochondrial code and the mycoplasma/spiroplasma code
         elif [[ $translate_table = 4 ]]
          then
           sed --regexp-extended \
            's/[tu]ga/M/gi'
          
         # Invertebrate Mitochondrial Code
          elif [[ $translate_table = 5 ]]
          then
           sed --regexp-extended \
            's/ag[ag]/S/gi;
             s/a[tu]a/M/gi;
             s/[tu]ga/W/gi'
          
         # Ciliate, Dasycladacean and Hexamita Nuclear Code
          elif [[ $translate_table = 6 ]]
          then
           sed --regexp-extended \
            's/[tu]a[ag]/Q/gi'
          
            
         # Echinoderm and Flatworm Mitochondrial Code
         elif [[ $translate_table = 9 ]]
          then
           sed --regexp-extended \
            's/aaa/N/gi;
             s/ag[ag]/S/gi;
             s/[tu]ga/W/gi'
             
         # Euplotid Nuclear Code
          elif [[ $translate_table = 10 ]]
          then
           sed --regexp-extended \
            's/[tu]ga/C/gi'
            
         # Bacterial, Archaeal and Plant Plastid Code
          elif [[ $translate_table = 11 ]]
          then
           cat
         
         # Alternative Yeast Nuclear Code
          elif [[ $translate_table = 12 ]]
          then
           sed --regexp-extended \
            's/c[tu]g/S/gi'
            
          # Ascidian Mitochondrial Code
          elif [[ $translate_table = 13 ]]
          then
           sed --regexp-extended \
            's/ag[ag]/G/gi;
             s/a[tu]a/M/gi;
             s/[tu]ga/W/gi'
             
          # Alternative Flatworm Mitochondrial Code
          elif [[ $translate_table = 14 ]]
          then
           sed --regexp-extended \
            's/aaa/N/gi;
             s/ag[ag]/S/gi;
             s/[tu]aa/Y/gi;
             s/[tu]ga/W/gi'
          
          # Chlorophycean Mitochondrial Code
          elif [[ $translate_table = 16 ]]
          then
           sed --regexp-extended \
            's/[tu]ag/L/gi'
            
          # Trematode Mitochondrial Code
          elif [[ $translate_table = 21 ]]
          then
           sed --regexp-extended \
            's/[tu]ga/W/gi;
             s/a[tu]a/M/gi;
             s/ag[ag]/S/gi;
             s/aaa/N/gi'
             
          # Scenedesmus obliquus Mitochondrial Code
          elif [[ $translate_table = 22 ]]
          then
           sed --regexp-extended \
            's/[tu]ca/*/gi;
             s/[tu]ag/L/gi'
             
          # Thraustochytrium Mitochondrial Code
          elif [[ $translate_table = 23 ]]
          then
           cat
           
          # Rhabdopleuridae Mitochondrial Code
          elif [[ $translate_table = 24 ]]
          then
           sed --regexp-extended \
            's/aga/S/gi;
             s/agg/K/gi;
             s/[tu]ga/W/gi'
          
          # Candidate Division SR1 and Gracilibacteria Code
          elif [[ $translate_table = 25 ]]
          then
           sed --regexp-extended \
            's/[tu]ga/G/gi'
            
          # Pachysolen tannophilus Nuclear Code
          elif [[ $translate_table = 26 ]]
          then
           sed --regexp-extended \
            's/c[tu]g/A/gi'
            
          # Karyorelict Nuclear Code
          elif [[ $translate_table = 27 ]]
          then
           sed --regexp-extended \
            's/[tu]a[ag]/Q/gi;
             s/[tu]ga/W/gi'
             
          # Condylostoma Nuclear Code
          elif [[ $translate_table = 28 ]]
          then
           sed --regexp-extended \
            's/[tu]a[ag]/Q/gi;
             s/[tu]ga/W/gi'
             
          # Mesodinium Nuclear Code
          elif [[ $translate_table = 29 ]]
          then
           sed --regexp-extended \
            's/[tu]a[ag]/Y/gi'
            
          # Peritrich Nuclear Code
          elif [[ $translate_table = 30 ]]
          then
           sed --regexp-extended \
            's/[tu]a[ag]/E/gi'
            
          # Blastocrithidia Nuclear Code
          elif [[ $translate_table = 31 ]]
          then
           sed --regexp-extended \
            's/[tu]a[ag]/E/gi;
             s/[tu]ga/W/gi'
             
          # Cephalodiscidae Mitochondrial UAA-Tyr Code
          elif [[ $translate_table = 33 ]]
          then
           sed --regexp-extended \
            's/[tu]aa/Y/gi;
             s/[tu]ga/W/gi;
             s/aga/S/gi;
             s/agg/K/gi'
             
         fi |
         
         # Standard code
         sed --regexp-extended \
         's/a[tu]g/M/gi;
          s/a[tu][tuc]|a[tu]a/I/gi;
          s/ac[actugn]/T/gi;
          s/aa[tuc]/N/gi;
          s/aa[ag]/K/gi;
          s/ag[tuc]|[tu]c[acgtun]/S/gi;
          s/[tu][tu][tuc]/F/gi;
          s/[tu]a[tuc]/Y/gi;
          s/[tu]g[tuc]/C/gi;
          s/[tu]gg/W/gi;
          s/c[tu][acgtun]|[tu][tu][ag]/L/gi;
          s/cc[acgtun]/P/gi;
          s/ca[tuc]/H/gi;
          s/ca[ag]/Q/gi;
          s/cg[acgtun]|ag[ag]/R/gi;
          s/g[tu][acgtun]/V/gi;
          s/gc[acgtun]/A/gi;
          s/ga[tcu]/D/gi;
          s/ga[ag]/E/gi;
          s/gg[acgtun]/G/gi;
          s/[tu]ga|[tu]a[ag]/*/gi'
}
  
  # Residue weights
  function calc_MW(){
	strand=$1
	cat $2 |
	if [[ $MOLECULE == "PROTEIN" ]]
	then
	 tr --delete "*Xx" |
	 parallel -k -j"$threads" --block 30M --pipe 'sed --regexp-extended \
         "s/M/131.1926 /gi;
          s/I/113.1594 /gi;
          s/T/101.1051 /gi;
          s/N/114.1038 /gi;
          s/K/128.1741 /gi;
          s/S/87.0782 /gi;
          s/F/147.1766 /gi;
          s/L/113.1594 /gi;
          s/Y/163.176 /gi;
          s/C/103.1388 /gi;
          s/W/186.2132 /gi;
          s/P/97.1167 /gi;
          s/H/137.1411 /gi;
          s/Q/128.1307 /gi;
          s/R/156.1875 /gi;
          s/V/99.1326 /gi;
          s/A/71.0788 /gi;
          s/D/115.0886 /gi;
          s/E/129.1155 /gi;
          s/G/57.0519 /gi;
          s/ $//g"' |
          awk -F ' ' '{for(i=1;i<=NF;i++) t+=$i; printf "%.5f\n", t+18.01528; t=0}'
         elif [[ $MOLECULE == "DNA" ]]
         then
         if [ $strand -eq 1 ]
         then
          parallel -k -j"$(($threads/2))" --block 30M --pipe 'sed --regexp-extended \
          "s/[^atcg]//gi;
           s/a/313.20672 /gi;
           s/t/304.19322 /gi;
           s/c/289.18182 /gi;
           s/g/329.20592 /gi;
           s/ $//g;"' |
           awk -F ' ' '{for(i=1;i<=NF;i++) t+=$i; printf "%.5f\n", t+18.01528+78.972; t=0}'
         else 
          parallel -k -j"$(($threads/2))" --block 30M --pipe 'sed --regexp-extended \
          "s/[^atcg]//gi;
           s/[at]/313.20672 304.19322 /gi;
           s/[cg]/289.18182 329.20592 /gi;
           s/ $//g"' |
           awk -F ' ' '{for(i=1;i<=NF;i++) t+=$i; printf "%.5f\n", t+2*(18.01528+78.972); t=0}'
         fi
         elif [[ $MOLECULE == "RNA" ]]
         then
         if [ $strand -eq 1 ]
         then
          parallel -k -j"$(($threads/2))" --block 30M --pipe 'sed --regexp-extended \
          "s/[^aucg]//gi;
           s/a/329.20592 /gi;
           s/u/306.16602 /gi;
           s/c/305.18122 /gi;
           s/g/345.20472 /gi;
           s/ $//g;"' |
           awk -F ' ' '{for(i=1;i<=NF;i++) t+=$i; printf "%.5f\n", t+18.01528+159.9588; t=0}'
          else
           parallel -k -j"$(($threads/2))" --block 30M --pipe 'sed --regexp-extended \
          "s/[^aucg]//gi;
           s/[au]/329.20592 306.16602 /gi;
           s/[cg]/305.18122 345.20472 /gi;
           s/ $//g;"' |
           awk -F ' ' '{for(i=1;i<=NF;i++) t+=$i; printf "%.5f\n", t+2*(18.01528+159.9588); t=0}'
          fi
          fi
     }
     
     function detect_mol(){
     local input=$(mktemp --tmpdir=$tmpdir fastakit.detect_mol.input.XXXXXXXXXX)
     input=$1
     if [ $(grep --ignore-case --max-count=1 --count --perl-regexp "[EFILPQ]" $input) -eq 0 ] || [ $((100 * $(grep --ignore-case --only-matching --perl-regexp "[DHKMRSVWY]" $input | tr -d "\n" | wc -m) / $(cat $input | tr -d "\n" | wc -m))) -lt 10 ]
     then
      export MOL=$(mktemp --tmpdir=$tmpdir fastakit.detect_mol.MOL.XXXXXXXXXX)
      export input
      parallel -j2 --halt now,success=1 ::: \
      'grep --ignore-case --max-count=1 "T" $input > /dev/null && echo "DNA" > $MOL' \
      'grep --ignore-case --max-count=1 "U" $input > /dev/null && echo "RNA" > $MOL' &> /dev/null
      MOLECULE=$(cat $MOL)
     else
      MOLECULE="PROTEIN"
     fi
     if [ ! -z ${detect+x} ]; then echo $MOLECULE; fi
     if [ ! -z ${verbose+x} ]; then echo "Detected molecule: "$MOLECULE >&2; fi
     }
     
     function get_enz(){
       local reheads=$(mktemp --tmpdir=$tmpdir fastakit.get_enz.reheads.XXXXXXXXXX)
       local repat=$(mktemp --tmpdir=$tmpdir fastakit.get_enz.repat.XXXXXXXXXX)
       local retmp=$(mktemp --tmpdir=$tmpdir fastakit.get_enz.retmp.XXXXXXXXXX)
       if [ ! -z ${verbose+x} ]; then echo "Downloading restriction enzyme recognition sites..." >&2; fi
       wget --quiet --show-progress --output-document=- ftp://ftp.neb.com/pub/rebase/withref.txt |
       grep --perl-regexp "\<1\>|\<5\>" |
       tr --delete "\n" |
       sed --regexp-extended 's/<1>/\n/g; s/<5>/\t/g' |
       grep --invert-match "?" |
       tee $reheads |
       cut --fields=2 |
       sed --regexp-extended \
       's/[?/\^()]//g;
       s/[0-9]//g;
       s/[-]//g;
       s/,/|/g;
       s/n/[actgu]/gi;
       s/r/[ag]/gi;
       s/y/[ctu]/gi;
       s/m/[ac]/gi;
       s/k/[gtu]/gi;
       s/s/[gc]/gi;
       s/w/[atu]/gi;
       s/b/[cgtu]/gi;
       s/d/[agtu]/gi;
       s/h/[actu]/gi;
       s/v/[acg]/gi' |
       grep --perl-regexp --invert-match "^$" > $repat
       paste <(cut --fields=1 $reheads | grep --perl-regexp --invert-match "^$") $repat |
       sort --field-separator=$'\t' --key=2,2 |
       uniq --skip-fields=1 --group="both" > $retmp
       paste <(cut --fields=1 $retmp | tr "\n" ";" | sed --regexp-extended 's/;;/\n/g; s/^;//g') <(cut --fields=2 $retmp | grep -v "^$" | uniq) \
       > $fastakit_dir"/neb_rebase"
     }
     
     function res_enz(){
      local input=$(mktemp --tmpdir=$tmpdir fastakit.res_enz.input.XXXXXXXXXX)
      local reout=$(mktemp --tmpdir=$tmpdir fastakit.res_enz.reout.XXXXXXXXXX)
      local enztmp=$(mktemp --tmpdir=$tmpdir fastakit.res_enz.enztmp.XXXXXXXXXX)
      local is_enz='[[:alpha:]]'
      cut --fields=2 $1 > $input
      local enz_name=$2
      local repat_min=$3
      local repat_max=$4
      local resites_min=$5
      local resites_max=$6
      local retmp=$fastakit_dir"/neb_rebase"
      
      # Create search arrays
       if [[ $enz_name =~ $is_enz ]]
       then
        repat_tmp=($(grep --ignore-case --perl-regexp '^'"$enz_name"'[\t;]|;'"$enz_name"'[\t;]' $retmp | tr "\t" " "))
        reheads=${repat_tmp[0]}
        repat=${repat_tmp[1]}	
        local repat_min=0
        local repat_max=0
       else
        repat=($(cut --fields=2 $retmp | tr "\n" " "))
        reheads=($(cut --fields=1 $retmp | tr "\n" " "))        
       fi
       
      # Loop over all restriction enzymes
       for ((re=0; re <= $((${#repat[@]} - 1)); re++))
       do
        repat_len=$(echo $(($(sed --regexp-extended 's/[[][actgu]+[]]/[/gi' <(echo "${repat[$re]}") | wc -m) - 1)))
        if [ "$repat_len" -lt "$repat_min" ] ||  ([ "$repat_max" -ne 0 ] && [ "$repat_len" -gt "$repat_max" ])
        then
         continue
        fi
        repat_tmp=${repat[$re]}
        reheads_tmp=${reheads[$re]}
        paste $reout <(awk -v repat="$repat_tmp" -v reheads="$reheads_tmp" -v resites_min="$resites_min" -v resites_max="$resites_max" \
        '{IGNORECASE = 1; seq=$0; renum=gsub(repat,"",seq);
        if($0 ~ repat && renum >= resites_min && (resites_max == 0 || renum <= resites_max))
        print reheads; else print ""}' $input |
        tr ";" "\t") > $enztmp
        SWITCH=$reout; reout=$enztmp; enztmp=$SWITCH
        if [ ! -z ${verbose+x} ]; then echo -en "\033[2K"$((100 * ($re + 1) / ${#repat[@]}))"% | "${reheads[$re]/;*}"\r" >&2; fi
       done
       if [ ! -z ${verbose+x} ]; then echo -en "\n\n" >&2; fi
       sed --regexp-extended 's/\t+/\t/g; s/^\t//g; s/\t$//g' $reout
       }
     
     # Random sequence function
     function random(){
     if [ $# -ge 1 -a -f "$1" ]
     then
      cat "$1"
     else
      cat -
     fi |
     if [[ $MOLECULE = "DNA" ]]
      then
       cut --fields=2 |
       awk -F $'\t' '{print system("tr --delete --complement ATGC < /dev/urandom | head --bytes="length($0))}' |
       tr --delete 0
      elif [[ $MOLECULE = "RNA" ]]
      then
       cut --fields=2 |
       awk -F $'\t' '{print system("tr --delete --complement AUCG < /dev/urandom | head --bytes="length($0))}' |
       tr --delete 0
      elif [[ $MOLECULE = "PROTEIN" ]]
      then
       cut --fields=2 |
       tr -d "*" |
       awk -F $'\t' '{print system("tr --delete --complement ARNCEQGHILKMFPSTWYV < /dev/urandom | head --bytes="length($0))}' |
       tr --delete 0
      else
       echo "Invalid molucule type!" >&2
       exit 1
      fi
      }
      
      # Multi-line conversion function
      function multiline(){
       cut --fields=2 "$1" |
       sed --regexp-extended "s/([ACTGUactgu]{$multi})/\1\t/g"
      }
      
      # Count non-nucleotide characters function
      fun_nonnuc(){
       paste <(cat $1 | tr --delete ">") <(cat $2 | tr --delete "ACTGUactgu" | awk '{print length($0)}') |
       grep --invert-match --perl-regexp "\t0"
      }
     
     # Sequence statistics function
     function seq_stats(){
     lengths=$(mktemp --tmpdir=$tmpdir fastakit.seq_stats.lengths.XXXXXXXXXX)
     awk '{print length($0)}' $1 | sort -rn > $lengths
     total=$(awk '{OFS="\t"}; {sum+=$0}; END{printf "%.0f", sum}' $lengths)
     L50_idx=$(awk '{OFS="\t"}; {sum+=$0}; {printf "%s%s%.0f\n", NR,OFS,sum}' $lengths |
     awk -v total=$total -F $'\t' '{if($2 > (total*0.5))printf "%.0f\n", $1}' |
     head -1)
     L90_idx=$(awk '{OFS="\t"}; {sum+=$0}; {printf "%s%s%.0f\n", NR,OFS,sum}' $lengths |
     awk -v total=$total -F $'\t' '{if($2 > (total*0.9))printf "%.0f\n", $1}' |
     head -1)
     num_seq=$(cat $lengths | wc -l)
     half_num=$(awk -v num_seq=$num_seq 'NR==(int(num_seq/2)+1){printf $0}' $lengths)
     echo -e "Total length\t"$total
     echo -e "Sequence #\t"$num_seq
     echo -e "Longest sequence\t"$(head -1 $lengths)
     echo -e "Shortest sequence\t"$(tail -1 $lengths)
     echo -e "Median\t"$(awk -v num_seq=$num_seq -v half_num=$half_num \
     'NR==int(num_seq/2){if(num_seq/2 == int(num_seq/2)) printf "%.1f", ($0+half_num)/2; else printf "%.0f", $0}' $lengths)
     echo -e "Mean\t"$(bc <<< "scale=2; $total/$num_seq")
     if [[ $MOLECULE != "PROTEIN" ]]
     then 
      echo -e "GC%\t"$(bc <<< "scale=2; $(cat $1 | tr --delete --complement "[GgCc]" | wc -m)*100/$(cat $1 | tr --delete --complement "[AaTtGgCcUu]" | wc -m)")
     fi
     echo -e "N50\t"$(awk -v L50_idx=$L50_idx 'NR==L50_idx{printf "%.0f", $0}' $lengths)
     echo -e "L50\t"$L50_idx
     echo -e "N90\t"$(awk -v L90_idx=$L90_idx 'NR==L90_idx{printf "%.0f", $0}' $lengths)
     echo -e "L90\t"$L90_idx
     }
     
     # Complementary sequnce function
     function fun_comp(){
     if test -n "$1"
      then
       cat $1
      else
       cat -
      fi |
     if [[ $MOLECULE = "DNA" ]]
      then
       parallel -k -j"$threads" --block 30M --pipe 'tr \"ATCGatcg\" \"TAGCtagc\"'
      elif [[ $MOLECULE = "RNA" ]]
      then
       parallel -k -j"$threads" --block 30M --pipe 'tr \"AUCGaucg\" \"UAGCuagc\"'
      else
       echo "Invalid molucule type!" >&2
       exit 1
      fi
      }
      
      # Reverse sequnce function
      function fun_rev(){
      if test -n "$1"
      then
       cat $1
      else
       cat -
      fi |
      parallel -a $1 -k -j"$threads" --block 30M --pipe 'rev'
      }
      
      # RNA-to-DNA conversion function
      function fun_rna_dna(){
      if test -n "$1"
      then
       cat $1
      else
       cat -
      fi |
      parallel -k -j"$threads" --block 30M --pipe 'tr \"TtUu\" \"UuTt\"'
      }
      
      # Thread calculation
     thread_calc(){
     local input=$1
     required_mem=$(echo $((2 * $(du -k $INFILE | cut --fields=1) / $threads)))
     available_mem=$(awk '/MemAvailable/ {print $2}' /proc/meminfo)
     seq_num=$(grep --perl-regexp --count "^>" $1)
     if [[ $seq_num -lt $threads ]]
     then
      threads=$seq_num
     fi
     
     # Setup start and end lines for dividing sequences
     BATCH=$(( seq_num / $threads ))
     remainder=$(( seq_num % $threads ))
     
     start=1
     end=()
     for ((core=0;core <= $(($threads - 1));core++))
     do
      if [[ ${#end[@]} != 0 ]]
      then
       start=(${start[@]} $((${end[$(($core - 1))]} + 1)))
      fi
      if [[ $core -lt $remainder ]]
      then
       end=(${end[@]} $((${start[$core]} + $BATCH)))
      else
       end=(${end[@]} $((${start[$core]} + $BATCH - 1)))
      fi
     done
     
     export start end
     }
      # ORF search
      function orf_search(){
       local SWITCH
       local ORFstart=$1
       local ORFend=$2
       local orf_core=$3
       local headcore_orf=HEADCORE$orf_core
       local outcore_orf=OUTCORE$orf_core
       
       if [[ $threads != 1 ]]
       then
        local ORFHEADERS=$(mktemp --tmpdir=$tmpdir fastakit.orf_search.ORFHEADERS.orf_core$orf_core.XXXXXXXXXX)
        local ORFFILE1=$(mktemp --tmpdir=$tmpdir fastakit.orf_search.ORFFILE1.orf_core$orf_core.XXXXXXXXXX)
        awk -v start="$ORFstart" -v end="$ORFend" 'NR>=start && NR<=end' $4 > $ORFFILE1
        awk -v start="$ORFstart" -v end="$ORFend" 'NR>=start && NR<=end' $5 > $ORFHEADERS
       else
        ORFFILE1=$4
        ORFHEADERS=$5
       fi
       
       if [ ! -z ${makeanno+x} ]
       then
        if [[ $threads != 1 ]]
        then
         local seq_length_orf=$(mktemp --tmpdir=$tmpdir fastakit.orf_search.seq_length_orf.orf_core$orf_core.XXXXXXXXXX)
         awk -v start="$ORFstart" -v end="$ORFend" 'NR>=start && NR<=end' $6 > $seq_length_orf
        else
         seq_length_orf=$6
        fi
      
       paste $ORFHEADERS \
       <(awk -F '' '{for (i = 1; i <= length($0); i += 3) { printf "%s%s%s ", substr($0, i, 1), substr($0, i+1, 1), substr($0, i+2, 1);}; print ""}' $ORFFILE1) \
       $seq_length_orf |
        awk -F $'\t' -v orf_core=$orf_core -v ORFend=$ORFend -v verbose=$verbose \
        '{OFS="\t"; IGNORECASE=1; len=split($2,arr," "); idx=1; orf=1; seek=0; delete start; delete stop; head=$1; gsub(">","",head);
        if($1 ~ /_frame/) {frame=substr($1,match($1,"_frame") + 6,1)} else {frame=1} ;
        if(FNR % 1000 && orf_core == 0 && verbose == 1){printf ("Getting ORFs: %d%\r", 100*FNR/ORFend) > "/dev/tty"};
        for(i=1;i<=len;i++) {
         if(arr[i] ~ /a[tu]g/ && seek == 0) {
          start[idx]=(i-1)*3; seek = 1 };
         if(arr[i] ~ /[tu][ag]a|[tu]ag/ && i >= 2 && seek == 1) {
          stop[idx]=(i-1)*3+4 ; seek = 0; print head"_orf"idx,frame,$3,start[idx],stop[idx]; idx++};
          };
          } END{if(orf_core == 0 && verbose == 1) print "\n" > "/dev/tty"}' > ${!outcore_orf}
       if [ $orf_core -eq 0 ] && [ ! -z ${verbose+x} ]; then echo "" >&2; fi
       else
        local ORFFILE2=$(mktemp --tmpdir=$tmpdir fastakit.orf_search.ORFFILE2.orf_core$orf_core.XXXXXXXXXX)
        paste $ORFHEADERS <(awk -F '' '{for (i = 1; i <= length($0); i += 3) { printf "%s%s%s ", substr($0, i, 1), substr($0, i+1, 1), substr($0, i+2, 1);}; print ""}' $ORFFILE1) |
        if [ ! -z ${upstream+x} ]
        then
         awk -F $'\t' -v max_orf_num="${max_orf_num:0}" -v upstream="$upstream" -v orf_core="$orf_core" -v ORFend=$ORFend -v verbose=$verbose \
         '{OFS="\t"; IGNORECASE=1; len=split($2,seq,"a[tu]g|[tu][ag]a|[tu]ag",sep); orf=1; seek=0;
         if(FNR % 1000 && orf_core == 0 && verbose == 1){printf ("Getting ORFs: %d%\r", 100*FNR/ORFend) > "/dev/tty"};
         if(FNR == ORFend && orf_core == 0 && verbose == 1) print "" > "/dev/tty";
         for(i in seq) {
         if(max_orf_num == 0 || orf <= max_orf_num){
         if(sep[i] ~ /a[tu]g/ && seek == 0) {
         move=1; flank=sep[i-move] seq[i]; gsub(" ","",flank); len_flank=length(flank);
         while(len_flank < upstream && (i - move) >= 1){
         move++;
         flank=sep[i-move] seq[i-move+1] flank;
         gsub(" ","",flank);
         len_flank=length(flank)
         };
         orf_out = $1"_orf"orf OFS substr(flank,length(flank) - upstream + 1) "\n";
         orf++; seek=1}
         else{
         if(sep[i] ~ /[tu][ag]a|[tu]ag/ && seek==1) {orf_outputs = orf_outputs orf_out; seek=0}
         }
         }}
         printf "%s", orf_outputs
         }'
        elif [ ! -z ${downstream+x} ]
        then
         awk -F $'\t' -v max_orf_num="${max_orf_num:0}" -v downstream="$downstream" -v orf_core="$orf_core" -v ORFend=$ORFend -v verbose=$verbose \
         '{OFS="\t"; IGNORECASE=1; len=split($2,seq,"a[tu]g|[tu][ag]a|[tu]ag",sep); orf=1; seek=0;
         if(FNR % 1000 && orf_core == 0 && verbose == 1){printf ("Getting ORFs: %d%\r", 100*FNR/ORFend) > "/dev/tty"};
         if(FNR == ORFend && orf_core == 0 && verbose == 1) print "" > "/dev/tty";
         for(i in seq) {
         if(max_orf_num == 0 || orf <= max_orf_num){
         if(sep[i] ~ /a[tu]g/ && seek == 0) {
         seek=1};
         if(sep[i] ~ /[tu][ag]a|[tu]ag/ && seek == 1) {
         move=1; flank=seq[i+move] sep[i+move]; gsub(" ","",flank); len_flank=length(flank);
         while(len_flank < downstream && (i + move) <= len){
         move++;
         flank=flank seq[i+move] sep[i+move];
         gsub(" ","",flank);
         len_flank=length(flank)
         };
         orf_outputs = orf_outputs $1"_orf"orf OFS substr(flank,1,downstream) "\n";
         orf++; seek=0}
         else{
         if(sep[i] ~ /[tu][ag]a|[tu]ag/ && sep[i-1] ~ /a[tu]g/ && i >= 2) {seek=0}
         }
         }}
         printf "%s", orf_outputs
         }'
        else
         awk -F $'\t' -v max_orf_num="${max_orf_num:0}" -v orf_core="$orf_core" -v ORFend=$ORFend -v verbose=$verbose \
         '{OFS="\t"; IGNORECASE=1; len=split($2,seq,"a[tu]g|[tu][ag]a|[tu]ag",sep); orf=1; seek=0; orf_outputs="";
         if(FNR % 1000 && orf_core == 0 && verbose == 1){printf ("Getting ORFs: %d%\r", 100*FNR/ORFend) > "/dev/tty"};
         if(FNR == ORFend && orf_core == 0 && verbose == 1) print "" > "/dev/tty";
         for(i in seq) {
         if((max_orf_num == 0 || orf <= max_orf_num) && i < len){
         if(sep[i] ~ /a[tu]g/ && seek == 0) {orf_out = $1"_orf"orf OFS sep[i] seq[i+1]; orf++; seek=1}
         else{
         if(sep[i] ~ /a[tu]g/ && seek == 1) {orf_out = orf_out sep[i] seq[i+1]};
         if(sep[i] ~ /[tu][ag]a|[tu]ag/ && seek == 1) {orf_outputs = orf_outputs orf_out sep[i] "\n"; seek=0}
         }}}
         printf "%s", orf_outputs
         }'
        fi |
        tee $ORFFILE2 |
        cut --fields=1 > ${!headcore_orf}
        cut --fields=2 $ORFFILE2 |
        if [ ! -z ${translate+x} ]
        then
         translate - |
         tr --delete " [:lower:]"
        else
         tr --delete " "
        fi > ${!outcore_orf}
       fi
      }
      
      extract_fun(){
       local SWITCH
       local ORFstart=$1
       local ORFend=$2
       local orf_core=$3
       local outcore_orf=OUTCORE$orf_core
       
       if [[ $threads != 1 ]]
       then
        local ORFFILE1=$(mktemp --tmpdir=$tmpdir fastakit.orf_search.ORFFILE1.orf_core$orf_core.XXXXXXXXXX)
        sed --quiet ''"$ORFstart"','"$ORFend"'p;'"$(($ORFend + 1))"'q' $4 > $ORFFILE1
       else
        ORFFILE1=$4
       fi
       
       if [ ! -z ${makeanno+x} ]
       then
        if [ $extract -eq 1 ]
         then
         awk -F $'\t' -v orf_core=$orf_core -v ORFend=$ORFend -v verbose=$verbose \
         '{OFS="\t"; len=split("A"$2"A",arr,"[A-Z]+"); split($2,arr2,"[a-z]+"); head=$1; gsub(">","",head);
         if(FNR % 1000 && orf_core == 0 && verbose == 1){printf ("Extracting lowercase: %d%\r", 100*FNR/ORFend) > "/dev/tty"};
         if(FNR == ORFend && orf_core == 0 && verbose == 1) print "" > "/dev/tty";
         count1=0; count2=length(arr2[1]);
         for(i=2;i<len;i++){
          print head"_extract"i-1,0,length(arr[i]),count1+count2+1,count1+count2+length(arr[i]);
          count1+=length(arr[i]);
          count2+=length(arr2[i])};
           }' $ORFFILE1
       else
        awk -F $'\t' -v orf_core=$orf_core -v ORFend=$ORFend -v verbose=$verbose \
         '{OFS="\t"; len=split("a"$2"a",arr,"[a-z]+"); split($2,arr2,"[A-Z]+"); head=$1; gsub(">","",head);
         if(FNR % 1000 && orf_core == 0 && verbose == 1){printf ("Extracting UPPERCASE: %d%\r", 100*FNR/ORFend) > "/dev/tty"};
         if(FNR == ORFend && orf_core == 0 && verbose == 1) print "" > "/dev/tty";
         count1=0; count2=length(arr2[1]);
         for(i=2;i<len;i++){
          print head"_extract"i-1,0,length(arr[i]),count1+count2+1,count1+count2+length(arr[i]);
          count1+=length(arr[i]);
          count2+=length(arr2[i])};
           }' $ORFFILE1       
       fi > ${!outcore_orf}
       if [ $orf_core -eq 0 ] && [ ! -z ${verbose+x} ]; then echo "" >&2; fi
       
       else
     if [ $extract -eq 1 ]
     then
      awk -F $'\t' -v orf_core=$orf_core -v ORFend=$ORFend -v verbose=$verbose \
         '{OFS="\t"; len=split("A"$2,arr,"[A-Z]+");
         if(FNR % 1000 && orf_core == 0 && verbose == 1){printf ("Extracting lowercase: %d%\r", 100*FNR/ORFend) > "/dev/tty"};
         if(FNR == ORFend && orf_core == 0 && verbose == 1) print "" > "/dev/tty";
         for(i=1;i<len-1;i++) {
          print $1"_extract"i,arr[i+1]};
           }' $ORFFILE1
     else
      awk -F $'\t' -v orf_core=$orf_core -v ORFend=$ORFend -v verbose=$verbose \
         '{OFS="\t"; len=split("a"$2,arr,"[a-z]+");
         if(FNR % 1000 && orf_core == 0 && verbose == 1){printf ("Extracting UPPERCASE: %d%\r", 100*FNR/ORFend) > "/dev/tty"};
         if(FNR == ORFend && orf_core == 0 && verbose == 1) print "" > "/dev/tty";
         for(i=1;i<len-1;i++) {
          print $1"_extract"i,arr[i+1]};
           }' $ORFFILE1
         
     fi > ${!outcore_orf}
       fi
      }
      
      makeanno_fun(){
      awk -F $'\t' -v min_seq_length="${seq_range[0]-0}" -v max_seq_length="${seq_range[1]-0}" -v name_regex=${name_regex-""} '{OFS="\t"};
      {headers=$1}; {gsub(/_orf[0-9]+/,"",$1)}; {gsub(/_frame[0-9]+/,"",$1)}; {gsub(/_extract[0-9]+/,"",$1)}; {gsub(name_regex,"",$1)};
      $2 ~ 0{if( $5-$4 >= min_seq_length && ($5-$4 <= max_seq_length || max_seq_length == 0)){
      print $1,$4,$5,$5-$4,headers,0,"+",$4,$5-1,"0,128,255"}}
      $2 ~ 1{if( $5-$4 >= min_seq_length && ($5-$4 <= max_seq_length || max_seq_length == 0)){
      print $1,$4,$5-1,$5-$4,headers,0,"+",$4,$5-1,"0,128,255"}}
      $2 ~ 2{if( $5-$4 >= min_seq_length && ($5-$4 <= max_seq_length || max_seq_length == 0)){
      print $1,$4+1,$5,$5-$4,headers,0,"+",$4+1,$5,"0,164,255"}}
      $2 ~ 3{if( $5-$4 >= min_seq_length && ($5-$4 <= max_seq_length || max_seq_length == 0)){
      print $1,$4+2,$5+1,$5-$4,headers,0,"+",$4+2,$5+1,"0,200,255"}}
      $2 ~ 4{if( $5-$4 >= min_seq_length && ($5-$4 <= max_seq_length || max_seq_length == 0))
      {print $1,$3-$5,$3-$4,$5-$4,headers,0,"-",$3-$5+1,$3-$4,"255,128,0"}}
      $2 ~ 5{if( $5-$4 >= min_seq_length && ($5-$4 <= max_seq_length || max_seq_length == 0)){
      print $1,$3-$5+1,$3-$4,$5-$4,headers,0,"-",$3-$5+1,$3-$4,"255,164,0"}}
      $2 ~ 6{if( $5-$4 >= min_seq_length && ($5-$4 <= max_seq_length || max_seq_length == 0)){
      print $1,$3-$5+1,$3-$4,$5-$4,headers,0,"-",$3-$5+1,$3-$4,"255,200,0"}}' $1 |
     if [ ! -z ${max_seq+x} ]
     then
      sort --parallel="$threads" --field-separator=$'\t' --key=1,1 --key=4,4nr |
      awk -F $'\t' -v max_seq="$max_seq" 'NR==1{i=1; head=$1}; {if($1 == head) {if(i <= max_seq){print $0; i++; head=$1} else next} else {print $0; i=2; head=$1}}' |
      sort --parallel="$threads" --field-separator=$'\t' --key=1,1 --key=2,2n
     else
      sort --parallel="$threads" --field-separator=$'\t' --key=1,1 --key=2,2n
     fi |
     if [ ! -z ${length_sort+x} ] && [ -z ${name_sort+x} ]
     then
     if [ ! -z ${reverse_sort+x} ]
      then
       sort --parallel="$threads" --field-separator=$'\t' --key=4,4nr
     else
       sort --parallel="$threads" --field-separator=$'\t' --key=4,4n
     fi
     else
      cat
     fi |
     if [ ! -z ${length_sort+x} ] && [ ! -z ${name_sort+x} ]
     then
     if [ ! -z ${reverse_sort+x} ]
      then
       sort --parallel="$threads" --field-separator=$'\t' --key=1,1 --key=4,4nr
     else
       sort --parallel="$threads" --field-separator=$'\t' --key=1,1 --key=4,4n
     fi
     else
      cat
     fi |
     if [ -z ${length_sort+x} ] && [ ! -z ${name_sort+x} ]
     then
     if [ ! -z ${reverse_sort+x} ]
      then
       sort --parallel="$threads" --field-separator=$'\t' --key=1,1r
     else
       sort --parallel="$threads" --field-separator=$'\t' --key=1,1
     fi
     else
      cat
     fi |
     cut --fields=1-3,5-10 |
     if [[ $makeanno == "GFF3" ]]
     then
      awk -F $'\t' '{OFS="\t"}; {print $1,"fastakit","CDS",$2+1,$3,$5,$6,0,"ID="$4"; Parent="$1}' |
      cat <(echo -e "##gff-version 3\n## Created with fastakit version "$version) -
     elif [[ $makeanno == "GTF" ]]
     then
      awk -F $'\t' '{OFS="\t"}; {print $1,"fastakit","CDS",$2+1,$3,$5,$6,0,"gene_id \""$1"\"; transcript_id \""$4"\""}' |
      cat <(echo -e "##gtf-version 2.2\n## Created with fastakit version "$version) -
     else
      cat <(echo -e "## BED format\n## Created with fastakit version "$version) -
     fi
     if [ ! -z ${verbose+x} ]
     then
      echo -ne "\nAnnotation file creation done: " >&2
      show_time
     fi
     exit 0
     }
          
###############################################
# Exceptions
      
  # upstream and downstream exceptions
  if [ ! -z ${upstream+x} ] || [ ! -z ${downstream+x} ]
  then
   orf=1
   unset translate
   if [ ! -z ${upstream+x} ] && [ ! -z ${downstream+x} ]
   then
    unset downstream
   fi
  fi
  
  # Frame exception
  for frame_test in ${frame[@]}
  do
   if [ $frame_test -lt 0 ] || [ $frame_test -gt 6 ]
  then
   echo "Frame value must be 0-6 (comma delimited)"
   print_usage
   exit 1
  fi
  done
  
  # max_seq exception
  if [ ! -z ${max_seq+x} ] && [ ! $max_seq -gt 0 ] 
  then
   echo "Error: max_seq must be greater than 0" >&2
   exit 1
  fi

  # Set six-frame array variable
  if [ $frame -eq 0 ]
   then
    frame=(1 2 3 4 5 6)
   fi

  # Disable rev-comp for reverse frames
  if [[ "${frame[@]}" =~ 4 ]] || [[ "${frame[@]}" =~ 5 ]] || [[ "${frame[@]}" =~ 6 ]]
   then
    unset $complement
    unset $rev_seq
   fi
   

  # Disable translate
  if [ ! -z ${percent_GC+x} ]
  then
   unset translate
  fi
  
  if [ ! -z ${makeanno+x} ]
  then
   if [ -z ${orf+x} ] && [ -z ${extract+x} ]
   then
    orf=1
   fi
   if [ $(grep --ignore-case --max-count=1 --count --perl-regexp "gff" <(echo $makeanno)) -eq 1 ]
   then
    makeanno=GFF3
   elif [ $(grep --ignore-case --max-count=1 --count --perl-regexp "gtf" <(echo $makeanno)) -eq 1 ]
   then
    makeanno=GTF
   else
    makeanno=BED
   fi
   unset translate
   translate_table=1
  fi
  
  # Get RE database if it doesn't exist
  if [ ! -f $fastakit_dir"/neb_rebase" ]
   then
    get_enz
   fi
  
  # Output list of REs
  if [[ ${min_max_re[0]=0} =~ "list" ]]
   then
    cut --fields=1 $fastakit_dir"/neb_rebase" |
    tr ";" "\n" |
    sort
    exit 0
  fi
  
##################################################################

    # Get input files
    INFILE=$(mktemp --tmpdir=$tmpdir fastakit.fastakit.INFILE.XXXXXXXXXX)
    if [ $# -ge 1 ]
    then
     if [ -f "$1" ]
     then
      FILE="$1"
      cp --force $FILE $INFILE
     elif [ -p "/dev/fd/${1#/dev/fd/}" ]
     then
      cat "$1" > $INFILE
     else
      echo "Invalid input provided" >&2
      printf "$usage" |
      awk -F $'\t' '{ printf "%-30s %s\n", $1, $2 }'
      exit 1
     fi
    elif [[ ! -t 0 ]]
    then
     cat - > $INFILE
    else
     echo "No input provided" >&2
     printf "$usage" |
     awk -F $'\t' '{ printf "%-30s %s\n", $1, $2 }'
     exit 1
    fi
    
    HEADERS=$(mktemp --tmpdir=$tmpdir fastakit.fastakit.HEADERS.XXXXXXXXXX)
    OUTFILE=$(mktemp --tmpdir=$tmpdir fastakit.fastakit.OUTFILE.XXXXXXXXXX)
    DETECT_sample=$(mktemp --tmpdir=$tmpdir fastakit.fastakit.DETECT_sample.XXXXXXXXXX)
    
    # Remove empty lines
    if [ $(grep --count --max-count=1 --perl-regexp "^$" $INFILE) -ge 1 ]
    then
     grep --invert-match --perl-regexp "^$" $INFILE > $OUTFILE
     SWITCH=$OUTFILE; OUTFILE=$INFILE; INFILE=$SWITCH
    fi
    
    # Check if FASTA
    if [ $(head --lines=1 $INFILE | grep --count --perl-regexp "^>") -eq 0 ]
    then
     echo -e "File doesn't start with '>' \nIs this a FASTA file?" >&2
     exit 1
    fi
    
    # Remove return carriages
    if [ $(head --lines=1 $INFILE | grep --count --perl-regexp "\r") -ge 1 ]
    then
     sed --regexp-extended 's/\r//g' $INFILE > $OUTFILE
     SWITCH=$OUTFILE; OUTFILE=$INFILE; INFILE=$SWITCH
    fi
    
    # Detect molecule and exit
    if [ ! -z ${detect+x} ]
    then
     grep --perl-regexp --invert-match "^>" $INFILE | head --bytes=5000000 > $DETECT_sample
     detect_mol $DETECT_sample
     exit 0
    fi
    
    if [ ! -z ${verbose+x} ]; then echo -en "Using "$threads" thread(s)\n\n" >&2; fi

    if [ ! -z ${rename+x} ]
    then
     echo ">"$rename$(seq -s "@>"$rename $(grep --count --perl-regexp "^>" $INFILE)) |
     tr "@" "\n" > $HEADERS
    else
     grep ">" $INFILE > $HEADERS
    fi
    
    # Tabs in headers exception
    if [ $(grep --perl-regexp --count --max-count=1 "\t" $HEADERS) -eq 1 ]
    then
     echo -e "Tab character in FASTA headers!" >&2
     exit 1
    fi

    
if [[ $(grep --before-context=1 --max-count=10 --invert-match ">" $INFILE | grep --count ">") != $(grep --before-context=1 --max-count=10 --invert-match ">" $INFILE | grep --count --invert-match ">") ]] || [[ $(wc --lines $HEADERS | cut --fields=1 --delimiter=" ") != $(grep --count --invert-match ">" $INFILE) ]]
    then
    
     if [ ! -z ${verbose+x} ]; then echo "FASTA file is NOT single line" >&2; fi
     if [ ! -z ${check_sl+x} ]; then exit 1; fi


    if [[ $lettercase = 0 ]]
    then
     if [ ! -z ${verbose+x} ]; then echo "Converting to single line FASTA" >&2; fi
     perl -pe '$. > 1 and /^>/ ? print "\n" : chomp' $INFILE |
     grep --invert-match ">" |
     tr --delete " " > $OUTFILE
     
    # Convert to upper-case
    elif [[ $lettercase = 1 ]]
     then
      if [ ! -z ${verbose+x} ]; then echo "Converting to upper-case single line FASTA" >&2; fi
      perl -pe '$. > 1 and /^>/ ? print "\n" : chomp' $INFILE |
      grep --invert-match ">" |
      tr "[:lower:]" "[:upper:]" |
      tr --delete " " > $OUTFILE
      
    # Convert to lower-case
     elif [[ $lettercase = 2 ]]
      then
       if [ ! -z ${verbose+x} ]; then echo "Converting to lower-case single line FASTA" >&2; fi
       perl -pe '$. > 1 and /^>/ ? print "\n" : chomp' $INFILE |
       grep --invert-match ">" |
       tr "[:upper:]" "[:lower:]" |
       tr --delete " " > $OUTFILE
      
     fi
     
     if [ ! -z ${verbose+x} ]
     then
      echo -n "Single line conversion done: " >&2
      show_time
     fi
     
    # Skip single line conversion
    else
    
    # Just load single-line sequences
    
     if [ ! -z ${verbose+x} ]; then echo "FASTA file is single line" >&2; fi
     if [ ! -z ${check_sl+x} ]; then exit 0; fi
     if [ ! -z ${verbose+x} ]; then echo "Skipping single line FASTA conversion" >&2; fi
     if [ ! -z ${verbose+x} ] && [[ $lettercase = 1 ]]; then echo "Converting to UPPER-case FASTA" >&2; fi
     if [ ! -z ${verbose+x} ] && [[ $lettercase = 2 ]]; then echo "Converting to lower-case FASTA" >&2; fi

    grep --invert-match ">" $INFILE |
    if [[ $lettercase = 0 ]]
    then
     tr --delete " " > $OUTFILE
    elif [[ $lettercase = 1 ]]
    then
     tr "[:lower:]" "[:upper:]" |
     tr --delete " " > $OUTFILE
    elif [[ $lettercase = 2 ]]
    then
     tr "[:upper:]" "[:lower:]" |
     tr --delete " " > $OUTFILE
    fi
    if [ ! -z ${verbose+x} ]
     then
      echo -n "Loading sequence done: " >&2
      show_time
     fi
    fi
    
    if [ $(grep --count --max-count=1 --perl-regexp "\t" $HEADERS) -gt 0 ]
    then
     tab_string=$(echo " $(tr -dc '[[:alnum:]]' < /dev/urandom | head -c 20) ")
     sed --in-place "s/\t/$tab_string/g" $HEADERS
    fi    
    
    
    head --bytes=5000000 $OUTFILE > $DETECT_sample
    detect_mol $DETECT_sample
    
    # Exception translate or orf for proteins
    if ([ ! -z ${translate+x} ] || [ ! -z ${orf+x} ]) && [[ $MOLECULE = "PROTEIN" ]]
    then
     echo "Can't get ORFs / translate protein sequences" >&2
     exit 1
    fi
    
    # Get subset of sequences from file
    if [ ! -z ${get_names+x} ]
    then
     SWITCH=$OUTFILE; OUTFILE=$INFILE; INFILE=$SWITCH
     HEADERS_TMP=$(mktemp --tmpdir=$tmpdir fastakit.fastakit.HEADERS_TMP.XXXXXXXXXX)
     awk -v get_names="$get_names" -F $'\t' '{OFS="\t"}; $1 ~ get_names{print $0}' <(paste $HEADERS $INFILE) |
     tee >(cut --fields=1 > $HEADERS_TMP) |
     cut --fields=2 > $OUTFILE
     HEADERS=$HEADERS_TMP
    fi
    
    if [ ! -z ${nonnuc+x} ]
    then
     SWITCH=$OUTFILE; OUTFILE=$INFILE; INFILE=$SWITCH
     fun_nonnuc $HEADERS $INFILE
     if [ ! -z ${verbose+x} ]
      then
       echo -n "Non-ACTGU done: " >&2
       show_time
      fi
     exit 0
    fi
        
     # Get complementary sequences
     if [ ! -z ${complement+x} ]
     then
      if [ ! -z ${verbose+x} ]
      then
       echo "Converting to complement sequence" >&2
      fi
      SWITCH=$OUTFILE; OUTFILE=$INFILE; INFILE=$SWITCH
      fun_comp $INFILE > $OUTFILE
      if [ ! -z ${verbose+x} ]
      then
       echo -n "Complement conversion done: " >&2
       show_time
      fi
     fi
     
     # DNA-to-RNA or RNA-to-DNA
     if [ ! -z ${rna_dna+x} ]
     then
      SWITCH=$OUTFILE; OUTFILE=$INFILE; INFILE=$SWITCH
      if [[ $MOLECULE = "DNA" ]]
      then
       if [ ! -z ${verbose+x} ]; then echo "Converting DNA to RNA sequence" >&2; fi
       MOLECULE="RNA"
      elif [[ $MOLECULE = "RNA" ]]
      then
       if [ ! -z ${verbose+x} ]; then echo "Converting RNA to DNA sequence" >&2; fi
       MOLECULE="DNA"
      else
       echo "Invalid molucule type!" >&2
       exit 1
      fi
      fun_rna_dna $INFILE > $OUTFILE
      if [ ! -z ${verbose+x} ]
       then
        echo -n "DNA/RNA conversion done: " >&2
        show_time
       fi
     fi

     # Get reverse sequences
     if [ ! -z ${rev_seq+x} ]
     then
      if [ ! -z ${verbose+x} ]; then echo "Converting to reverse sequence" >&2; fi
      SWITCH=$OUTFILE; OUTFILE=$INFILE; INFILE=$SWITCH
      fun_rev $INFILE > $OUTFILE
      if [ ! -z ${verbose+x} ]
      then
       echo -n "Reverse conversion done: " >&2
       show_time
      fi
     fi
     
     # Change frame
     if [ "${#frame[@]}" -ne 1 ] || [ ${frame[0]} -ne 1 ]
     then
     SWITCH=$OUTFILE; OUTFILE=$INFILE; INFILE=$SWITCH
     ADD_frame=$(mktemp --tmpdir=$tmpdir fastakit.fastakit.ADD_frame.XXXXXXXXXX)
     ADD_headers=$(mktemp --tmpdir=$tmpdir fastakit.fastakit.ADD_headers.XXXXXXXXXX)
     if [[ "${frame[@]}" =~ 1 ]]
     then
      cat $INFILE >> $ADD_frame
      awk -F $'\t' '{print $0"_frame1"}' $HEADERS >> $ADD_headers
     fi
     if [[ "${frame[@]}" =~ 2 ]]
     then
      sed --regexp-extended 's/^.//g' $INFILE >> $ADD_frame
      awk -F $'\t' '{print $0"_frame2"}' $HEADERS >> $ADD_headers
     fi
     if [[ "${frame[@]}" =~ 3 ]]
     then
      sed --regexp-extended 's/^..//g' $INFILE >> $ADD_frame
      awk -F $'\t' '{print $0"_frame3"}' $HEADERS >> $ADD_headers
     fi
     if [[ "${frame[@]}" =~ 4 ]] || [[ "${frame[@]}" =~ 5 ]] || [[ "${frame[@]}" =~ 6 ]]
     then
      INFILE_revcomp=$(mktemp --tmpdir=$tmpdir fastakit.fastakit.INFILE_revcomp.XXXXXXXXXX)
      fun_rev $INFILE |
      fun_comp > $INFILE_revcomp
      if [[ "${frame[@]}" =~ 4 ]]
      then
       cat $INFILE_revcomp >> $ADD_frame
       awk -F $'\t' '{print $0"_frame4"}' $HEADERS >> $ADD_headers
      fi
      if [[ "${frame[@]}" =~ 5 ]]
      then
       sed --regexp-extended 's/^.//g' $INFILE_revcomp >> $ADD_frame
       awk -F $'\t' '{print $0"_frame5"}' $HEADERS >> $ADD_headers
      fi
      if [[ "${frame[@]}" =~ 6 ]]
      then
       sed --regexp-extended 's/^..//g' $INFILE_revcomp >> $ADD_frame
       awk -F $'\t' '{print $0"_frame6"}' $HEADERS >> $ADD_headers
      fi
     fi
     HEADERS=$ADD_headers
     OUTFILE=$ADD_frame
     fi
     
     # Verbose sequence cutoffs
     if [ ! -z ${verbose+x} ] && [ ! -z $seq_range ]
     then
      if [[ $MOLECULE == "PROTEIN" ]]
      then
       mol_unit="aa"
      else
       mol_unit="bp"
      fi
      if [ ${seq_range[0]} -eq 0 ]
      then
       echo "Extracting sequences under "${seq_range[1]}" "$mol_unit >&2
      elif [ ${seq_range[1]} -eq 0 ]
      then
       echo "Extracting sequences over "${seq_range[0]}" "$mol_unit >&2
      else
       echo "Extracting sequences between "${seq_range[0]}" and "${seq_range[1]}" "$mol_unit >&2
      fi
     fi
     if [ ! -z ${verbose+x} ] && [ ! -z $max_seq ]; then echo "Extracting "$max_seq" longest sequence(s) for each input sequence" >&2; fi

     # ORF finding
     if [ ! -z ${orf+x} ]
     then
     if [ ! -z ${verbose+x} ]; then echo "ORF | frame(s) "${frame[@]} >&2; fi
     if [ ! -z ${translate+x} ] && [ ! -z ${verbose+x} ]; then echo "Translate | frame(s) "${frame[@]} >&2; fi
     if [ $translate_table -ne 1 ] && [ ! -z ${verbose+x} ]; then echo "Translation code: "$translate_table >&2; fi
     if [ ! -z ${makeanno+x} ] && [ ! -z ${verbose+x} ]; then echo "Output in "$makeanno" format" >&2; fi
     
     SWITCH=$OUTFILE; OUTFILE=$INFILE; INFILE=$SWITCH
     
     # Allocate sequences to requested threads
     thread_calc $HEADERS $INFILE
     
     # Loop for function getting ORFs for multithreading
     HEADERS_TMP=$(mktemp --tmpdir=$tmpdir fastakit.fastakit.HEADERS_TMP.XXXXXXXXXX)
     : > $OUTFILE 

      for ((core=0;core <= $(($threads - 1));core++))
      do
       declare OUTCORE$core=$(mktemp --tmpdir=$tmpdir fastakit.fastakit.OUTCORE$core.XXXXXXXXXX)
       declare HEADCORE$core=$(mktemp --tmpdir=$tmpdir fastakit.fastakit.HEADCORE$core.XXXXXXXXXX)
       
       if [ ! -z ${makeanno+x} ]
       then
        orf_search ${start[$core]} ${end[$core]} $core $INFILE $HEADERS <(awk -F $'\t' '{print length($0)}' $INFILE) &
        pids[$core]=$!
       else
        orf_search ${start[$core]} ${end[$core]} $core $INFILE $HEADERS &
        pids[$core]=$!
       fi
      done
      
      for pid in ${pids[*]}
      do
       wait $pid
      done
            
      for ((core=0;core <= $(($threads - 1));core++))
      do
      if [ ! -z ${makeanno+z} ]
      then
       outcore_tmp=OUTCORE$core
       cat ${!outcore_tmp} >> $OUTFILE
      else
       headcore_tmp=HEADCORE$core
       outcore_tmp=OUTCORE$core
       cat ${!headcore_tmp} >> $HEADERS_TMP
       cat ${!outcore_tmp} >> $OUTFILE
      fi
      done
      
     HEADERS=$HEADERS_TMP
     
     if [ ! -z ${makeanno+x} ]
     then
     SWITCH=$OUTFILE; OUTFILE=$INFILE; INFILE=$SWITCH
     makeanno_fun $INFILE
     fi

     if [ ! -z ${verbose+x} ] && [ -z ${translate+x} ]
     then
      echo -n "ORF detection done: " >&2
      show_time
     fi
     if [ ! -z ${verbose+x} ] && [ ! -z ${translate+x} ]
     then
      echo -n "ORF detection and translation done: " >&2
      show_time
     fi
     head --bytes=5000000 $OUTFILE > $DETECT_sample
     detect_mol $DETECT_sample
    fi
    
    # Separate to codons and translate
    if [ ! -z ${translate+x} ] && [ -z ${orf+x} ]
    then
     SWITCH=$OUTFILE; OUTFILE=$INFILE; INFILE=$SWITCH
     if [ ! -z ${verbose+x} ]
     then
      echo "Translate | frame(s) "${frame[@]} >&2
     fi
     if [ ! -z ${verbose+x} ] && [ $translate_table -ne 1 ]
     then
      echo "Translation code: "$translate_table >&2
     fi
     awk -F '' '{for (i = 1; i <= length($0); i += 3) { printf "%s%s%s ", substr($0, i, 1), substr($0, i+1, 1), substr($0, i+2, 1);}; print ""}' $INFILE |
      translate - |
       tr --delete " [:lower:]" > $OUTFILE
       if [ ! -z ${verbose+x} ]
       then
        echo -n "Translation done: " >&2
        show_time
       fi
       head --bytes=5000000 $OUTFILE > $DETECT_sample
       detect_mol $DETECT_sample
    fi
    
    # Minimum/Maximum length
     if [ ! -z ${seq_range+x} ]
     then
     SWITCH=$OUTFILE; OUTFILE=$INFILE; INFILE=$SWITCH
      awk -v min_seq_length="${seq_range[0]}" -v max_seq_length="${seq_range[1]}" \
      '{seq=$0; gsub("*","",seq); if(length(seq) >= min_seq_length && (length(seq) <= max_seq_length || max_seq_length == 0)) print $0;
      else print ""}' $INFILE > $OUTFILE
     fi
    
    # Randomize sequences
    if [ ! -z ${random+x} ]
     then
      SWITCH=$OUTFILE; OUTFILE=$INFILE; INFILE=$SWITCH
      random $INFILE > $OUTFILE
      if [ ! -z ${verbose+x} ]
      then
       echo -n "Random sequence done: " >&2
       show_time
      fi
     fi

#####################################################################
     
     # Combine headers and sequences
     SWITCH=$OUTFILE; OUTFILE=$INFILE; INFILE=$SWITCH
     paste $HEADERS $INFILE |
     grep --perl-regexp --invert-match "\t$" > $OUTFILE
     
    if [ ! -z ${extract+x} ]
    then
    SWITCH=$OUTFILE; OUTFILE=$INFILE; INFILE=$SWITCH
    : > $OUTFILE
    thread_calc $HEADERS $INFILE
    
    for ((core=0;core <= $(($threads - 1));core++))
     do
      declare OUTCORE$core=$(mktemp --tmpdir=$tmpdir fastakit.fastakit.OUTCORE$core.XXXXXXXXXX)
      declare HEADCORE$core=$(mktemp --tmpdir=$tmpdir fastakit.fastakit.HEADCORE$core.XXXXXXXXXX)
      extract_fun ${start[$core]} ${end[$core]} $core $INFILE &
      pids[$core]=$!
     done
     
     for pid in ${pids[*]}
      do
       wait $pid
      done
      
      for ((core=0;core <= $(($threads - 1));core++))
      do
       outcore_tmp=OUTCORE$core
       cat ${!outcore_tmp} >> $OUTFILE
      done
      
     if [ ! -z ${makeanno+x} ]
     then
      SWITCH=$OUTFILE; OUTFILE=$INFILE; INFILE=$SWITCH
      makeanno_fun $INFILE
     fi
     fi
     
     # Get max_seq number of largest sequences from each input sequence
     if [ ! -z ${max_seq+x} ]
     then
      SWITCH=$OUTFILE; OUTFILE=$INFILE; INFILE=$SWITCH
      awk -F $'\t' -v name_regex=${name_regex-""} \
      '{OFS="\t"}; {headers=$1}; {seq=$2}; {gsub(/_orf[0-9]+/,"",$1)}; {gsub(/_frame[0-9]+/,"",$1)}; {gsub(/_extract[0-9]+/,"",$1)}; {gsub(name_regex,"",$1)}; {gsub("*","",$2)};
      {print length($2),$1,headers,seq}' $INFILE |
      sort --parallel="$threads" --field-separator=$'\t' --key=2,2 --key=1,1nr |      
      awk -F $'\t' -v max_seq="$max_seq" \
      'NR==1{i=1; head=$2}; {if($2 == head) {if(i <= max_seq){print $0; i++; head=$2} else next} else {print $0; i=2; head=$2}}' |
      cut --fields=3,4 > $OUTFILE
     fi
     
     if [ ! -z ${unique+x} ]
     then
      SWITCH=$OUTFILE; OUTFILE=$INFILE; INFILE=$SWITCH
      sort --ignore-case --parallel="$threads" --field-separator=$'\t' --unique --key=2,2 $INFILE > $OUTFILE
      if [ ! -z ${verbose+x} ]
      then
       echo -n "Remove duplicates done: " >&2
       show_time
      fi
     fi
     
     # Sort by name
     if [ ! -z ${name_sort+x} ]
     then
     if [ ! -z ${verbose+x} ]
     then
      echo "Sort by name" >&2
     fi
      SWITCH=$OUTFILE; OUTFILE=$INFILE; INFILE=$SWITCH
      if [ ! -z ${reverse_sort+x} ]
      then
      if [ ! -z ${verbose+x} ]
      then
       echo "Sort in reverse order" >&2
      fi
       sort --parallel="$threads" --reverse --field-separator=$'\t' --key=1 $INFILE > $OUTFILE
      else
       sort --parallel="$threads" --field-separator=$'\t' --key=1 $INFILE > $OUTFILE
      fi
      if [ ! -z ${verbose+x} ]
      then
       echo -n "Name sort done: " >&2
       show_time
      fi
     fi
    
    # Sort by sequence length
     if [ ! -z ${length_sort+x} ]
     then
      if [ ! -z ${verbose+x} ]
      then
       echo "Sort by length" >&2
      fi
      SWITCH=$OUTFILE; OUTFILE=$INFILE; INFILE=$SWITCH    
      awk -F '\t' '{OFS="\t"; print length($2),$0}' $INFILE |
      if [ ! -z ${reverse_sort+x} ]
      then
      if [ ! -z ${verbose+x} ]
      then
       echo "Sort in reverse order" >&2
      fi
       sort --parallel="$threads" --field-separator=$'\t' --numeric-sort --reverse
      else
       sort --parallel="$threads" --field-separator=$'\t' --numeric-sort
      fi |
      cut --fields=2,3 > $OUTFILE
      if [ ! -z ${verbose+x} ]
      then
       echo -n "Length sort done: " >&2
       show_time
      fi
     fi
     
     # Sort by molecular weight
     if [ ! -z ${MW_sort+x} ]
     then
      if [ ! -z ${verbose+x} ]
      then
       echo "Sort by molecular weight" >&2
      fi
      SWITCH=$OUTFILE; OUTFILE=$INFILE; INFILE=$SWITCH
      paste <(cut --fields=2 $INFILE | calc_MW 1) $INFILE |
      if [ ! -z ${reverse_sort+x} ]
      then
      if [ ! -z ${verbose+x} ]
      then
       echo "Sort in reverse order" >&2
      fi
       sort --parallel="$threads" --field-separator=$'\t' --numeric-sort --reverse
      else
       sort --parallel="$threads" --field-separator=$'\t' --numeric-sort
      fi |
      cut --fields=2,3 > $OUTFILE
      if [ ! -z ${verbose+x} ]
      then
       echo -n "Molecular weight sort done: " >&2
       show_time
      fi
     fi
     
#####################################################
    # Ending functions
     
    # GC content
     if [ ! -z ${percent_GC+x} ]
     then
     if [ ! -z ${verbose+x} ]
     then
      echo "Percent GC" >&2
     fi
     SWITCH=$OUTFILE; OUTFILE=$INFILE; INFILE=$SWITCH
      paste <(cut --fields=1 $INFILE | tr --delete ">") <(cut --fields=2 $INFILE | awk '{var=length($0);gsub("[AaTt]","",$0);print length($0)/var*100}')
      if [ ! -z ${verbose+x} ]
      then
       echo -n "GC fraction done: " >&2
       show_time
      fi
      exit 0
     fi
     
     # Calculate molucular weight
    if [ ! -z ${MW+x} ]
    then
    if [ ! -z ${verbose+x} ]; then echo "Calculating molecular weight" >&2; fi
     SWITCH=$OUTFILE; OUTFILE=$INFILE; INFILE=$SWITCH
     if [[ $MOLECULE == "DNA" ]] || [[ $MOLECULE = "RNA" ]]
     then
      paste <(cut --fields=1 $INFILE | tr --delete ">") <(cut --fields=2 $INFILE | calc_MW 1 -) <(cut --fields=2 $INFILE | calc_MW 2 -)
     elif [[ $MOLECULE == "PROTEIN" ]]
     then
      paste <(cut --fields=1 $INFILE | tr --delete ">") <(cut --fields=2 $INFILE | calc_MW 1)
     else
      echo "Error detecting molecule" >&2
      exit 1
     fi
     if [ ! -z ${verbose+x} ]
      then
       echo -n "Molecular weight done: " >&2
       show_time
      fi
      exit 0
    fi
    
     # Detect restriction sites
     if [ ! -z ${renz+x} ] && [[ $MOLECULE != "PROTEIN" ]]
     then
     SWITCH=$OUTFILE; OUTFILE=$INFILE; INFILE=$SWITCH
     if [ ! -z ${verbose+x} ]; then echo "Detecting restriction sites" >&2; fi
      if [[ "${min_max_re[0]=0}" =~ "list" ]]
       then
        res_enz $INFILE ${min_max_re[0]=0} ${min_max_re[1]=0} ${min_max_re[2]=0} ${min_max_re[3]=0} ${min_max_re[4]=0}
        exit 0
      else
      paste <(cut --fields=1 $INFILE | tr --delete ">") \
      <(res_enz $INFILE ${min_max_re[0]=0} ${min_max_re[1]=0} ${min_max_re[2]=0} ${min_max_re[3]=0} ${min_max_re[4]=0}) |
      grep --perl-regexp --invert-match "\t$"
      fi
      if [ ! -z ${verbose+x} ]
      then
       echo -n "Restriction site detection done: " >&2
       show_time
      fi
      exit 0
     fi
     
     # Separate sequences into files
     if [ ! -z ${separate+x} ]
     then
     if [ ! -z ${verbose+x} ]; then echo "Separating sequences into files" >&2; fi
      if [ ! -d $separate ]
      then
       mkdir -p $separate
      fi
      for ((k=1;k<=$(cat $OUTFILE | wc -l);k++))
      do
       cut --fields=1 $OUTFILE | sed --quiet ''"$k"','"$k"'p;'"$(($k + 1))"'q' > $separate/$k.fasta
       cut --fields=2 $OUTFILE | sed --quiet ''"$k"','"$k"'p;'"$(($k + 1))"'q' >> $separate/$k.fasta
      done
      if [ ! -z ${verbose+x} ]
      then
       echo -en "\nSequence separation done: " >&2
       show_time
      fi
      exit 0
     fi
     
    if [ ! -z ${stats+x} ]
    then
     cut --field=2 $OUTFILE > $INFILE
     seq_stats $INFILE
     if [ ! -z ${verbose+x} ]
      then
       echo -n "Sequence statistics done: " >&2
       show_time
      fi
     exit 0
    fi
    
##################################
    # OUTPUT

     # Convert to Multi-line FASTA
    if [ ! -z ${multi+x} ]
    then
     if [ ! -z ${verbose+x} ]; then echo "Converting to multi line FASTA" >&2; fi
     SWITCH=$OUTFILE; OUTFILE=$INFILE; INFILE=$SWITCH
     paste <(cut --fields=1 $INFILE) <(multiline $INFILE) > $OUTFILE
     if [ ! -z ${verbose+x} ]
     then
      echo -ne "\nMulti line conversion done: " >&2
      show_time
     fi
    fi
    
     # Convert tabbed to FASTA
     SWITCH=$OUTFILE; OUTFILE=$INFILE; INFILE=$SWITCH
     cat $INFILE |
     tr "\t" "\n" |
     if [ ! -z ${tab_string+x} ]
     then
      sed "s/$tab_string/\t/g"
     else
      cat
     fi > $OUTFILE
     
    # Output inplace or stdout
    if [ ! -z ${inplace+x} ] && [ ! -z ${FILE+x} ]
     then
      cp --force $OUTFILE $FILE
     else
      cat $OUTFILE
     fi
    
    if [ ! -z ${verbose+x} ]
    then
     echo -ne "\nfastakit done: " >&2
     show_time
    fi
