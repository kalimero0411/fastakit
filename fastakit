#!/usr/bin/env bash
#set -x
# Default parameters
threads=$(command -v nproc --all &> /dev/null && nproc || echo 1)
lettercase=0
frame=1
translate_table=1
time_start=$(date +%s)

function print_usage(){
 printf "
fastakit [OPTIONS] [Sequence.fasta | stdin]
	-o | --out	Output to file (otherwise to stdout)
	-i | --in-place	Modify file in-place
	-c | --complement	Complementary sequence
	-m | --reverse_seq	Reverse sequence
	--unique	Remove duplicate sequences
	--multi #	Convert to multi-line FASTA (nucleotide only)
	--random	Create random sequences of respective length
	-n | --name_sort	Sort FASTA by name
	-l | --length_sort	Sort FASTA by sequence length (shortest to longest)
	-r | --reverse_sort	Sort in reverse order
	--upper	Sequences to uppercase
	--lower	Sequences to lowercase
	-g | --orf	Sequence from first ATG in frame
	--max_orf_num #	Maximum number of ORFs to output per sequence
	-p | --translate	Protein sequences in current frame
	--table #	Translation code (Default = standard code)
	--frame #	Frame to extract codons (Any of frames 1,2,3,4,5,6; 0 = six frames; Default = 1)
	--min_prot #	Minimum protein size (Assumes --translate)
	--gc	Calculate percent GC per sequence (Disables --translate)
	--mw	Calculate the moleculare weight of DNA/RNA/protein per sequence (ss ds)
	--separate DIR	Separate sequnces into files in directory DIR
	--nonnuc	Non-ACTGU characters (0 ignored)
	--rna_dna	Convert RNA to DNA / DNA to RNA (Default = no conversion)
	--min_max_seq #,#	Minimum/Maximum sequence size (e.g. 10,50 ; 0 to ignore)
	--maxseq Return the # of largest sequences for each input sequence (ORFs, proteins, etc.)
	--check	Check if FASTA file is single line
	--fullprot	Return only ORFs/proteins with start and stop codons
	--re #,#,#,#	Detect restriction enzyme recognition sites (min_length,max_length,min_number,max_number; 0 to ignore)
	--ignorestart	Ignore start codon when getting ORFs
	-t | --threads #	Number of CPU threads to use (Default = Detected processors or 1)
	-v | --verbose	Verbose
	-h | --help	Display help
	--stats	Calculate basic stats
	--version	Print version date


	Available translation codes:
	1 - Standard code
	2 - Vertebrate Mitochondrial code
	3 - Yeast mitochondrial code
	4 - Mold, protozoan, and coelenterate mitochondrial code and the mycoplasma/spiroplasma code
	
"
}

# Check arguments
while [ "$#" -gt 0 ]
do
arg=$1
 case $arg in
  -o | --out)
  out=1 # Output to file
  output_file=$2
  shift 2
  ;;
  -i | --in-place)
  inplace=1 # Modify file in-place
  shift
  ;;
  --unique)
  unique=1 # Remove duplicate sequences
  shift
  ;;
  -n | --name_sort)
  name_sort=1 # Sort FASTA file by name
  shift
  ;;
  --random)
  random=1 # Sort FASTA file by name
  shift
  ;;
  -l | --length_sort)
  length_sort=1 # Sort FASTA file by sequence length
  shift
  ;;
  -r | --reverse_sort)
  reverse_sort=1 # Sort in reverse order
  shift
  ;;
  --upper)
  lettercase=1 # Sequences to uppercase
  shift
  ;;
  --lower)
  lettercase=2 # Sequences to lowercase
  shift
  ;;
  -c | --complement)
  complement=1 # Complementary sequences
  shift
  ;;
  -m | --reverse_seq)
  rev_seq=1 # Reverse sequences
  shift
  ;;
  --frame) # Set frame for codons
  frame=($(sed 's/,/ /g' <(echo $2)))
  shift 2
  ;;
  -g | --orf)
  orf=1 # Sequence from first ATG in frame
  shift
  ;;
  --max_orf_num)
  max_orf_num=$2 # Maximum number of ORFs per sequence
  shift 2
  ;;
  -p | --translate)
  translate=1 # Translate sequences
  shift
  ;;
  --gc)
  percent_GC=1 # Get percent GC per sequence
  shift
  ;;
  --rna_dna)
  rna_dna=1 # Convert RNA to DNA / DNA to RNA
  shift
  ;;
  --nonnuc)
  nonnuc=1 # Count non-ACTGU characters
  shift
  ;;
  --separate)
  separate=$2 # Separate sequnces into files
  shift 2
  ;;
  --table)
  translate_table=$2 # Alternative translation table
  shift 2
  ;;
  --maxseq)
  maxseq=$2 # Return # of largest proteins
  shift 2
  ;;
  --version)
  echo "fastakit version 22.04" >> $(readlink /proc/$$/fd/2)
  exit 0
  ;;
  --check)
  check_sl=1
  shift
  ;;
  --min_prot)
  min_prot=1 # Minimum protein size
  translate=1 # Translate sequences
  min_prot_length=$2
  shift 2
  ;;
  --min_max_seq)
  OFS=$IFS
  IFS=","
  IFS="," min_max_seq_length=($(echo "$2")) # Minimum/Maximum nucleotide sequence size
  IFS=$OFS
  shift 2
  ;;
  -t | --threads)
  threads=$2 # Number of CPU threads
  shift 2
  ;;
  --stats)
  stats=1 # Calculate basic stats
  shift
  ;;
  --multi)
  multi=1 # Covert to multiline FASTA
  multi_length=$2
  shift 2
  ;;
  --fullprot)
  fullprot=1
  shift
  ;;
  --ignorestart)
  ignorestart=1
  shift
  ;;
  --mw)
  MW=1
  shift
  ;;
  --re)
  renz=1
  OFS=$IFS
  IFS=","
  min_max_re=($(echo "$2")) # Minimum/Maximum re length/number
  IFS=$OFS
  shift 2
  ;;
  -v | --verbose)
  verbose=1 # Print file names and arguments
  shift
  ;;
  -h | --help)
  print_usage
  exit 1
  ;;
  *)
  if [ -f "$1" ]
  then
   break
  else
  echo "Unknown option: "$1
  print_usage
  exit 1
  fi
  ;;
  esac
  done
  
  # Check dependencies
  if ! command -v gawk &> /dev/null
  then
   echo "gawk not installed" >> $(readlink /proc/$$/fd/2)
   echo "Install using:" >> $(readlink /proc/$$/fd/2)
   echo "sudo apt install gawk" >> $(readlink /proc/$$/fd/2)
  exit 1
  fi
  
  if ! command -v perl &> /dev/null
  then
   echo "perl not installed" >> $(readlink /proc/$$/fd/2)
   echo "Install using:" >> $(readlink /proc/$$/fd/2)
   echo "sudo apt install perl" >> $(readlink /proc/$$/fd/2)
  exit 1
  fi
  
  if ! command -v parallel &> /dev/null
  then
   echo "parallel not installed" >> $(readlink /proc/$$/fd/2)
   echo "Install using:" >> $(readlink /proc/$$/fd/2)
   echo "sudo apt install parallel" >> $(readlink /proc/$$/fd/2)
  exit 1
  fi
  
  # Time function
  function show_time(){
    num=$1
    min=0
    hour=0
    day=0
    if((num>59));then
        ((sec=num%60))
        ((num=num/60))
        if((num>59));then
            ((min=num%60))
            ((num=num/60))
            if((num>23));then
                ((hour=num%24))
                ((day=num/24))
            else
                ((hour=num))
            fi
        else
            ((min=num))
        fi
    else
        ((sec=num))
    fi
    echo "$day"d "$hour"h "$min"m "$sec"s >> $(readlink /proc/$$/fd/2)
}

  # Translation function
  function translate(){
	input=$1 &&
	cat $input |
	sed --regexp-extended \
        's/a[tu]g/M/gi;
         s/a[tu][tuc]/I/gi;
         s/ac[actug]/T/gi;
         s/aa[tuc]/N/gi;
         s/aa[ag]/K/gi;
         s/ag[tuc]/S/gi;
         s/[tu][tu][tuc]/F/gi;
         s/[tu][tu][ag]/L/gi;
         s/[tu]c[acgtu]/S/gi;
         s/[tu]a[tuc]/Y/gi;
         s/[tu]a[ag]/*/gi;
         s/[tu]g[tuc]/C/gi;
         s/[tu]gg/W/gi;
         s/cc[acgtu]/P/gi;
         s/ca[tuc]/H/gi;
         s/ca[ag]/Q/gi;
         s/cg[gtu]/R/gi;
         s/g[tu][acgtu]/V/gi;
         s/gc[acgtu]/A/gi;
         s/ga[tcu]/D/gi;
         s/ga[ag]/E/gi;
         s/gg[acgtu]/G/gi' |
         
         # Standard code
         if [[ $translate_table = 1 ]]
         then
          sed --regexp-extended \
           's/a[tu]a/I/gi;
            s/ag[ag]/R/gi;
            s/c[tu][acgtu]/L/gi;
            s/cg[ac]/R/gi;
            s/[tu]ga/*/gi;'
       
         # Vertebrate mitochondrial code
         elif [[ $translate_table = 2 ]]
         then
          sed --regexp-extended \
           's/a[tu]a/M/gi;
            s/ag[ag]/*/gi;
            s/c[tu][acgtu]/L/gi;
            s/cg[ac]/R/gi;
            s/[tu]ga/W/gi;'
       
         # Yeast mitochondrial code
         elif [[ $translate_table = 3 ]]
          then
          sed --regexp-extended \
           's/a[tu]a/M/gi;
            s/ag[ag]/R/gi;
            s/c[tu][acgtu]/T/gi;
            s/cg[ac]/X/gi;
            s/[tu]ga/W/gi;'
       
         # Mold, protozoan, and coelenterate mitochondrial code and the mycoplasma/spiroplasma code
         elif [[ $translate_table = 4 ]]
          then
           sed --regexp-extended \
            's/a[tu]a/I/gi;
             s/ag[ag]/R/gi;
             s/c[tu][acgtu]/L/gi;
             s/cg[ac]/R/gi;
             s/[tu]ga/M/gi;'
          else
           echo "Error: Unknown translation code"
           tables
           exit 1
         fi
}
  
  # Residue weights
  function calc_MW(){
	strand=$1
	cat $2 |
	if [[ $MOLECULE == "PROTEIN" ]]
	then
	 tr -d "*Xx" |
	 parallel -k -j"$threads" --block 30M --pipe 'sed --regexp-extended \
         "s/M/131.1926 /gi;
          s/I/113.1594 /gi;
          s/T/101.1051 /gi;
          s/N/114.1038 /gi;
          s/K/128.1741 /gi;
          s/S/87.0782 /gi;
          s/F/147.1766 /gi;
          s/L/113.1594 /gi;
          s/Y/163.176 /gi;
          s/C/103.1388 /gi;
          s/W/186.2132 /gi;
          s/P/97.1167 /gi;
          s/H/137.1411 /gi;
          s/Q/128.1307 /gi;
          s/R/156.1875 /gi;
          s/V/99.1326 /gi;
          s/A/71.0788 /gi;
          s/D/115.0886 /gi;
          s/E/129.1155 /gi;
          s/G/57.0519 /gi;
          s/ $//g"' |
          awk -F ' ' '{for(i=1;i<=NF;i++) t+=$i; printf "%.5f\n", t+18.01528; t=0}'
         elif [[ $MOLECULE == "DNA" ]]
         then
         if [ $strand -eq 1 ]
         then
          parallel -k -j"$(($threads/2))" --block 30M --pipe 'sed --regexp-extended \
          "s/a/313.20672 /gi;
           s/t/304.19322 /gi;
           s/c/289.18182 /gi;
           s/g/329.20592 /gi;
           s/ $//g;"' |
           awk -F ' ' '{for(i=1;i<=NF;i++) t+=$i; printf "%.5f\n", t+18.01528; t=0}'
         else 
          parallel -k -j"$(($threads/2))" --block 30M --pipe 'sed --regexp-extended \
          "s/[at]/313.20672 304.19322 /gi;
           s/[cg]/289.18182 329.20592 /gi;
           s/ $//g;"' |
           awk -F ' ' '{for(i=1;i<=NF;i++) t+=$i; printf "%.5f\n", t+(2*18.01528); t=0}'
         fi
         elif [[ $MOLECULE == "RNA" ]]
         then
         if [ $strand -eq 1 ]
         then
          parallel -k -j"$(($threads/2))" --block 30M --pipe 'sed --regexp-extended \
          "s/a/313.20672 /gi;
           s/u/306.16602 /gi;
           s/c/289.18182 /gi;
           s/g/329.20592 /gi;
           s/ $//g;"' |
           awk -F ' ' '{for(i=1;i<=NF;i++) t+=$i; printf "%.5f\n", t+18.01528; t=0}'
          else
           parallel -k -j"$(($threads/2))" --block 30M --pipe 'sed --regexp-extended \
          "s/[au]/313.20672 306.16602 /gi;
           s/[cg]/289.18182 329.20592 /gi;
           s/ $//g;"' |
           awk -F ' ' '{for(i=1;i<=NF;i++) t+=$i; printf "%.5f\n", t+18.01528; t=0}'
          fi
          fi
     }
     
     function detect_mol(){
     local input=$1
     if $(head -5 $input | awk '{seq=length($0); gsub("[actguACTGU]","",$0)}; length($0)/seq > 0.25{exit 1}')
     then
      MOL=$(mktemp)
      export input
      export MOL
      parallel -j2 --halt now,success=1 ::: \
      'grep --ignore-case --max-count=1 "T" $input > /dev/null && echo "DNA" > $MOL' \
      'grep --ignore-case --max-count=1 "U" $input > /dev/null && echo "RNA" > $MOL' &> /dev/null
      MOLECULE=$(cat $MOL)
     else
      MOLECULE="PROTEIN"
     fi
     rm --force $MOL
     if [ ! -z ${verbose+x} ]; then echo "Detected molecule: "$MOLECULE >> $(readlink /proc/$$/fd/2); fi
     }
     
     function res_enz(){
      local input=$(mktemp)
      local reout=$(mktemp)
      local enztmp=$(mktemp)
      cut --fields=2 $1 > $input
      local repat_min=$2
      local repat_max=$3
      local resites_min=$4
      local resites_max=$5
      
      # Get list of all restriction enzymes and their regex pattern
      if [ -f $(echo $(dirname $(readlink --canonicalize $(which fastakit)))"/neb_rebase") ]
      then
       local retmp=$(echo $(dirname $(readlink --canonicalize $(which fastakit)))"/neb_rebase")
       local repat=($(cut --fields=2 $retmp | tr "\n" " "))
       local reheads=($(cut --fields=1 $retmp | tr "\n" " "))
      else
       reheads=$(mktemp)
       repat=$(mktemp)
       retmp=$(mktemp)
       if [ ! -z ${verbose+x} ]; then echo "Downloading restriction enzyme recognition sites..." >> $(readlink /proc/$$/fd/2); fi
       wget --quiet --output-document=- ftp://ftp.neb.com/pub/rebase/withref.txt |
       grep --perl-regexp "\<1\>|\<5\>" |
       tr -d "\n" |
       sed --regexp-extended 's/<1>/\n/g; s/<5>/\t/g' |
       grep --invert-match "?" |
       tee $reheads |
       cut -f2 |
       sed --regexp-extended \
       's/[?/\^()]//g;
       s/[0-9]//g;
       s/[-]//g;
       s/,/|/g;
       s/n/[actgu]/gi;
       s/r/[ag]/gi;
       s/y/[ctu]/gi;
       s/m/[ac]/gi;
       s/k/[gtu]/gi;
       s/s/[gc]/gi;
       s/w/[atu]/gi;
       s/b/[cgtu]/gi;
       s/d/[agtu]/gi;
       s/h/[actu]/gi;
       s/v/[acg]/gi' |
       grep --perl-regexp --invert-match "^$" > $repat
       paste <(cut --fields=1 $reheads | grep --perl-regexp --invert-match "^$") $repat |
       sort -k2,2 | uniq -f1 --group="both" > $retmp
       paste <(cut --fields=1 | tr "\n" ";" | sed -E 's/;;/\n/g; s/^;//g' $retmp) <(cut --fields=2 | grep -v "^$" | uniq) > $repat
       rm --force $retmp
       retmp=$repat
       rm --force $repat $reheads
       repat=($(cut --fields=2 $retmp | tr "\n" " "))
       reheads=($(cut --fields=1 $retmp | tr "\n" " "))
       rm --force $retmp
      fi
      
      # Loop over all restriction enzymes
      for ((re=0; re <= $((${#repat[@]} - 1)); re++))
      do
       repat_len=$(echo $(($(sed --regexp-extended 's/[[][actgu]+[]]/[/gi' <(echo "${repat[$re]}") | wc -m) - 1)))
       if [ "$repat_len" -lt "$repat_min" ] ||  ([ "$repat_max" -ne 0 ] && [ "$repat_len" -gt "$repat_max" ])
       then
        continue
       fi
       repat_tmp=${repat[$re]}
       reheads_tmp=${reheads[$re]}
       paste $reout <(awk -v repat="$repat_tmp" -v reheads="$reheads_tmp" -v resites_min="$resites_min" -v resites_max="$resites_max" '{IGNORECASE = 1; seq=$0; renum=gsub(repat,"",seq); if($0 ~ repat && renum >= resites_min && (resites_max == 0 || renum <= resites_max)) print reheads; else print ""}' $input | tr ";" "\t") > $enztmp
       SWITCH=$reout; reout=$enztmp; enztmp=$SWITCH
       if [ ! -z ${verbose+x} ]; then echo -en "\033[2K"$((100 * ($re + 1) / ${#repat[@]}))"% | "${reheads[$re]/;*}"\r" >> $(readlink /proc/$$/fd/2); fi
      done
      if [ ! -z ${verbose+x} ]; then echo -en "\n\n" >> $(readlink /proc/$$/fd/2); fi
      sed --regexp-extended 's/\t+/\t/g; s/^\t//g; s/\t$//g' $reout
      rm --force $enztmp $reout $input
     }

  # Frame exception
  for frame_test in ${frame[@]}
  do
   if [ $frame_test -lt 0 ] || [ $frame_test -gt 6 ]
  then
   echo "Frame value must be 0-6 (comma delimited)"
   print_usage
   exit 1
  fi
  done

  # Set six-frame array variable
  if [ $frame -eq 0 ]
   then
    frame=(1 2 3 4 5 6)
   fi

  # Disable rev-comp for reverse frames
  if [[ "${frame[@]}" =~ 4 ]] || [[ "${frame[@]}" =~ 5 ]] || [[ "${frame[@]}" =~ 6 ]]
   then
    unset $complement
    unset $rev_seq
   fi

  # Disable translate
  if [ ! -z ${percent_GC+x} ]
  then
   unset translate
  fi
  
    # Get input files
    if [ $# -ge 1 -a -f "$1" ]
    then
    FILE="$1"
    else
    stdin=1
    FILE=$(mktemp)
    cat /dev/stdin > $FILE
    fi

    HEADERS=$(mktemp)
    INFILE=$(mktemp)
    OUTFILE=$(mktemp)
    
    if [ ! -z ${verbose+x} ]; then echo -en "Using "$threads" thread(s)...\n\n" >> $(readlink /proc/$$/fd/2); fi

    parallel -a $FILE -k -j"$threads" --block 30M --pipepart 'grep --perl-regexp "^>"' |
    sed --regexp-extended 's/\r//g' > $HEADERS
    
    if [[ $(grep --count --perl-regexp "^>" $FILE) != $(grep --count --perl-regexp --invert-match "^>" $FILE) ]]
    then
    
     if [ ! -z ${verbose+x} ]; then echo "FASTA file is NOT single line" >> $(readlink /proc/$$/fd/2); fi
     if [ ! -z ${check_sl+x} ]; then exit 1; fi


    if [[ $lettercase = 0 ]]
    then
     if [ ! -z ${verbose+x} ]; then echo "Converting to single line FASTA..." >> $(readlink /proc/$$/fd/2); fi
     sed --regexp-extended 's/\r//g' $FILE |
     perl -pe '$. > 1 and /^>/ ? print "\n" : chomp' |
     grep --perl-regexp --invert-match "^>" > $OUTFILE
     
    # Convert to upper-case
    elif [[ $lettercase = 1 ]]
     then
      if [ ! -z ${verbose+x} ]; then echo "Converting to upper-case single line FASTA..." >> $(readlink /proc/$$/fd/2); fi
      sed --regexp-extended 's/\r//g' $FILE |
      perl -pe '$. > 1 and /^>/ ? print "\n" : chomp' |
      grep --perl-regexp --invert-match "^>" |
      tr "[:lower:]" "[:upper:]" > $OUTFILE
      
    # Convert to lower-case
     elif [[ $lettercase = 2 ]]
      then
       if [ ! -z ${verbose+x} ]; then echo "Converting to lower-case single line FASTA..." >> $(readlink /proc/$$/fd/2); fi
       sed --regexp-extended 's/\r//g' $FILE |
       perl -pe '$. > 1 and /^>/ ? print "\n" : chomp' |
       grep --perl-regexp --invert-match "^>" |
       tr "[:upper:]" "[:lower:]" > $OUTFILE
      
    fi
     if [ ! -z ${verbose+x} ]
     then
      echo -n "Single line conversion done: " >> $(readlink /proc/$$/fd/2)
      show_time $(($(date +%s) - time_start))
      echo "" >> $(readlink /proc/$$/fd/2)
     fi
     
    # Skip single line conversion
    else
    
    # Just load single-line sequences
    
     if [ ! -z ${verbose+x} ]; then echo "FASTA file is single line" >> $(readlink /proc/$$/fd/2); fi
     if [ ! -z ${check_sl+x} ]; then exit 0; fi
     if [ ! -z ${verbose+x} ]; then echo "Skipping single line FASTA conversion..." >> $(readlink /proc/$$/fd/2); fi
    if [[ $lettercase = 0 ]]
    then
     parallel -a $FILE -k -j"$threads" --block 30M --pipepart 'grep --perl-regexp --invert-match "^>"' \
     > $OUTFILE
    elif [[ $lettercase = 1 ]]
    then
     if [ ! -z ${verbose+x} ]; then echo "Converting to upper-case FASTA..." >> $(readlink /proc/$$/fd/2); fi
     parallel -a $FILE -k -j"$threads" --block 30M --pipepart 'grep --perl-regexp --invert-match "^>"' |
     tr "[:lower:]" "[:upper:]" > $OUTFILE
    elif [[ $lettercase = 2 ]]
    then
     if [ ! -z ${verbose+x} ]; then echo "Converting to lower-case FASTA..." >> $(readlink /proc/$$/fd/2); fi
     parallel -a $FILE -k -j"$threads" --block 30M --pipepart 'grep --perl-regexp --invert-match "^>"' |
     tr "[:upper:]" "[:lower:]" > $OUTFILE
    fi
    if [ ! -z ${verbose+x} ]
     then
      echo -n "Loading sequence done: " >> $(readlink /proc/$$/fd/2)
      show_time $(($(date +%s) - time_start))
      echo "" >> $(readlink /proc/$$/fd/2)
     fi
    fi
    
     # Convert to Multi-line FASTA
    if [ ! -z ${multi+x} ]
     then
     if [ ! -z ${verbose+x} ]; then echo "Converting to multi line FASTA..." >> $(readlink /proc/$$/fd/2); fi
     SWITCH=$OUTFILE; OUTFILE=$INFILE; INFILE=$SWITCH
     paste $HEADERS $INFILE |
     grep --perl-regexp --invert-match "\t$" |
     tr "\t" "\n" |
      if [ $(grep --count --perl-regexp --ignore-case "^>.+[ACTGU]{$multi_length}" $HEADERS) -eq 0 ]
      then
       sed --regexp-extended "s/\r//g; s/([ACTGUactgu]{$multi_length})/\1\n/g"
      else
       awk -F "" -v multi_length="$multi_length" '/>/{print $0}; !/>/{for(i=1; i<=NF; i+=multi_length) {print substr($0,i,multi_length);}}'
      fi > $OUTFILE
      # Output to file or stdout
    if [ ! -z ${out+x} ]
    then
     if [ ! -z ${verbose+x} ]
     then
      echo $(basename $1)" ---> "$output_file >> $(readlink /proc/$$/fd/2)
     fi
     cp --force $OUTFILE $output_file
    else
     if [ ! -z ${inplace+x} ]
     then
      cp --force $OUTFILE $FILE
     else
      cat $OUTFILE
     fi
    fi
    
    # Cleanup temp files
    rm --force $OUTFILE $INFILE $HEADERS
    if [ ! -z ${stdin+x} ]
    then
     rm --force $FILE
    fi
    
    if [ ! -z ${verbose+x} ]
    then
     echo -ne "\nMulti line conversion done: " >> $(readlink /proc/$$/fd/2)
     show_time $(($(date +%s) - time_start)) >> $(readlink /proc/$$/fd/2)
    fi
    exit 0
    fi
    
    if [ ! -z ${nonnuc+x} ]
    then
     SWITCH=$OUTFILE; OUTFILE=$INFILE; INFILE=$SWITCH
     paste <(cat $HEADERS | tr -d ">") <(cat $INFILE | tr -d "ACTGUactgu" | awk '{print length($0)}') |
     grep --invert-match --perl-regexp "\t0"
     if [ ! -z ${verbose+x} ]
      then
       echo -n "Non-ACTGU done: " >> $(readlink /proc/$$/fd/2)
       show_time $(($(date +%s) - time_start))
       echo "" >> $(readlink /proc/$$/fd/2)
      fi
     exit 0
    fi
    
    if [ ! -z ${stats+x} ]
    then
     lengths=$(mktemp)
     awk '{print length($0)}' $OUTFILE | sort -rn > $lengths
     total=$(awk '{OFS="\t"}; {sum+=$0}; END{printf "%.0f", sum}' $lengths)
     l50_idx=$(awk '{OFS="\t"}; {sum+=$0}; {printf "%s%s%.0f\n", NR,OFS,sum}' $lengths | awk -v total=$total -F $'\t' '{if($2 > (total*0.5))printf "%.0f\n", $1}' | head -1)
     l90_idx=$(awk '{OFS="\t"}; {sum+=$0}; {printf "%s%s%.0f\n", NR,OFS,sum}' $lengths | awk -v total=$total -F $'\t' '{if($2 > (total*0.9))printf "%.0f\n", $1}' | head -1)
     num_seq=$(cat $lengths | wc -l)
     half_num=$(awk -v num_seq=$num_seq 'NR==(int(num_seq/2)+1){printf $0}' $lengths)
     echo -e "Total length\t"$total >> $(readlink /proc/$$/fd/2)
     echo -e "Sequence #\t"$num_seq >> $(readlink /proc/$$/fd/2)
     echo -e "Longest sequence\t"$(head -1 $lengths) >> $(readlink /proc/$$/fd/2)
     echo -e "Shortest sequence\t"$(tail -1 $lengths) >> $(readlink /proc/$$/fd/2)
     echo -e "Median\t"$(awk -v num_seq=$num_seq -v half_num=$half_num 'NR==int(num_seq/2){if(num_seq/2 == int(num_seq/2)) printf "%.1f", ($0+half_num)/2; else printf "%.0f", $0}' $lengths) >> $(readlink /proc/$$/fd/2)
     echo -e "Mean\t"$(bc <<< "scale=2; $total/$num_seq") >> $(readlink /proc/$$/fd/2)
     echo -e "GC%\t"$(bc <<< "scale=2; $(cat $OUTFILE | tr -d "\n" | tr -d "[AaTtUu]" | wc -m)*100/$(cat $OUTFILE | tr -d "\n" | wc -m)") >> $(readlink /proc/$$/fd/2)
     echo -e "L50\t"$(awk -v l50_idx=$l50_idx 'NR==l50_idx{printf "%.0f", $0}' $lengths) >> $(readlink /proc/$$/fd/2)
     echo -e "N50\t"$l50_idx >> $(readlink /proc/$$/fd/2)
     echo -e "L90\t"$(awk -v l90_idx=$l90_idx 'NR==l90_idx{printf "%.0f", $0}' $lengths) >> $(readlink /proc/$$/fd/2)
     echo -e "N90\t"$l90_idx >> $(readlink /proc/$$/fd/2)
     rm --force $lengths
     exit 0
    fi
    
    if [ ! -z ${complement+x} ] || [ ! -z ${rna_dna+x} ] || [ ! -z ${random+x} ] || [ ! -z ${renz+x} ]
    then
     detect_mol $OUTFILE
    fi
     
     if [ ! -z ${random+x} ]
     then
      SWITCH=$OUTFILE; OUTFILE=$INFILE; INFILE=$SWITCH
      if [[ $MOLECULE = "DNA" ]]
      then
       awk -F $'\t' '{print system("tr -dc atcg < /dev/urandom | head -c "length($0))}' $INFILE |
      tr -d 0 > $OUTFILE
      elif [[ $MOLECULE = "RNA" ]]
      then
       awk -F $'\t' '{print system("tr -dc aucg < /dev/urandom | head -c "length($0))}' $INFILE |
      tr -d 0 > $OUTFILE
      fi
      if [ ! -z ${verbose+x} ]
      then
       echo -n "Random sequence done: " >> $(readlink /proc/$$/fd/2)
       show_time $(($(date +%s) - time_start))
       echo "" >> $(readlink /proc/$$/fd/2)
      fi
     fi

     # Get complementary sequences
     if [ ! -z ${complement+x} ]
     then
      if [ ! -z ${verbose+x} ]
      then
       echo "Converting to complement sequence..." >> $(readlink /proc/$$/fd/2)
      fi
      SWITCH=$OUTFILE; OUTFILE=$INFILE; INFILE=$SWITCH
      if [[ $MOLECULE = "DNA" ]]
      then
       parallel -a $INFILE -k -j"$threads" --block 30M --pipepart 'tr \"ATCGatcg\" \"TAGCtagc\"' > $OUTFILE
      else
       parallel -a $INFILE -k -j"$threads" --block 30M --pipepart 'tr \"AUCGaucg\" \"UAGCuagc\"' > $OUTFILE
      fi
      if [ ! -z ${verbose+x} ]
      then
       echo -n "Complement conversion done: " >> $(readlink /proc/$$/fd/2)
       show_time $(($(date +%s) - time_start))
       echo "" >> $(readlink /proc/$$/fd/2)
      fi
     fi
     
     # DNA-to-RNA or RNA-to-DNA
     if [ ! -z ${rna_dna+x} ]
     then
      SWITCH=$OUTFILE; OUTFILE=$INFILE; INFILE=$SWITCH
      if [[ $MOLECULE = "DNA" ]]
      then
       if [ ! -z ${verbose+x} ]
       then
        echo "Converting DNA to RNA sequence..." >> $(readlink /proc/$$/fd/2)
       fi
       parallel -a $INFILE -k -j"$threads" --block 30M --pipepart 'tr \"Tt\" \"Uu\"' > $OUTFILE
       if [ ! -z ${verbose+x} ]
       then
        echo -n "DNA-to-RNA conversion done: " >> $(readlink /proc/$$/fd/2)
        show_time $(($(date +%s) - time_start))
        echo "" >> $(readlink /proc/$$/fd/2)
       fi
      else
       if [ ! -z ${verbose+x} ]
       then
        echo "Converting RNA to DNA sequence..." >> $(readlink /proc/$$/fd/2)
       fi
       parallel -a $INFILE -k -j"$threads" --block 30M --pipepart 'tr \"Uu\" \"Tt\"' > $OUTFILE
       if [ ! -z ${verbose+x} ]
       then
        echo -n "RNA-to-DNA conversion done: " >> $(readlink /proc/$$/fd/2)
        show_time $(($(date +%s) - time_start))
        echo "" >> $(readlink /proc/$$/fd/2)
       fi
      fi
     fi

     # Get reverse sequences
     if [ ! -z ${rev_seq+x} ]
     then
      if [ ! -z ${verbose+x} ]
      then
       echo "Converting to reverse sequence..." >> $(readlink /proc/$$/fd/2)
      fi
      SWITCH=$OUTFILE; OUTFILE=$INFILE; INFILE=$SWITCH
      parallel -a $INFILE -k -j"$threads" --block 30M --pipepart 'rev' > $OUTFILE
      if [ ! -z ${verbose+x} ]
      then
       echo -n "Reverse conversion done: " >> $(readlink /proc/$$/fd/2)
       show_time $(($(date +%s) - time_start))
       echo "" >> $(readlink /proc/$$/fd/2)
      fi
     fi
     
     # Change frame
     if [ "${#frame[@]}" -ne 1 ] || [ ${frame[0]} -ne 1 ]
     then
     SWITCH=$OUTFILE; OUTFILE=$INFILE; INFILE=$SWITCH
     ADD_frame=$(mktemp)
     ADD_headers=$(mktemp)
     if [[ "${frame[@]}" =~ 1 ]]
     then
      cat $INFILE >> $ADD_frame
      awk -F $'\t' '{print $0"_frame1"}' $HEADERS >> $ADD_headers
     fi
     if [[ "${frame[@]}" =~ 2 ]]
     then
      sed --regexp-extended 's/^.//g' $INFILE >> $ADD_frame
      awk -F $'\t' '{print $0"_frame2"}' $HEADERS >> $ADD_headers
     fi
     if [[ "${frame[@]}" =~ 3 ]]
     then
      sed --regexp-extended 's/^..//g' $INFILE >> $ADD_frame
      awk -F $'\t' '{print $0"_frame3"}' $HEADERS >> $ADD_headers
     fi
     if [[ "${frame[@]}" =~ 4 ]] || [[ "${frame[@]}" =~ 5 ]] || [[ "${frame[@]}" =~ 6 ]]
     then
      INFILE_revcomp=$(mktemp)
      parallel -a $INFILE -k -j"$threads" --block 30M --pipepart 'rev' |
      parallel -k -j"$threads" --block 30M --pipe 'tr \"ATCGUatcgu\" \"TAGCAtagca\"' \
      > $INFILE_revcomp
      if [[ "${frame[@]}" =~ 4 ]]
      then
       cat $INFILE_revcomp >> $ADD_frame
       awk -F $'\t' '{print $0"_frame4"}' $HEADERS >> $ADD_headers
      fi
      if [[ "${frame[@]}" =~ 5 ]]
      then
       sed --regexp-extended 's/^.//g' $INFILE_revcomp >> $ADD_frame
       awk -F $'\t' '{print $0"_frame5"}' $HEADERS >> $ADD_headers
      fi
      if [[ "${frame[@]}" =~ 6 ]]
      then
       sed --regexp-extended 's/^..//g' $INFILE_revcomp >> $ADD_frame
       awk -F $'\t' '{print $0"_frame6"}' $HEADERS >> $ADD_headers
      fi
     fi
     rm --force $OUTFILE $INFILE_revcomp $HEADERS
     HEADERS=$ADD_headers
     OUTFILE=$ADD_frame
     fi

     if [ ! -z ${orf+x} ]
     then
     if [ ! -z ${verbose+x} ] && [ ! -z ${orf+x} ]
     then
      echo "ORF | frame(s) "${frame[@]} >> $(readlink /proc/$$/fd/2)
     fi
     if [ ! -z ${verbose+x} ] && [ ! -z ${translate+x} ]
     then
      echo "Translate | frame(s) "${frame[@]} >> $(readlink /proc/$$/fd/2)
     fi
     if [ ! -z ${verbose+x} ] && [ $translate_table -ne 1 ]
     then
      echo "Translation code: "$translate_table >> $(readlink /proc/$$/fd/2)
     fi
     if [ ! -z ${verbose+x} ] && [ ! -z ${min_prot+x} ]
     then
      echo "Minimum protein length: "$min_prot_length >> $(readlink /proc/$$/fd/2)
     fi
     
     SWITCH=$OUTFILE; OUTFILE=$INFILE; INFILE=$SWITCH
     
     function get_orfs(){
     
     local SWITCH
     local ORFstart=$1
     local ORFend=$2
     local orf_core=$3
     local ORFHEADERS=$(mktemp)
     local ORFFILE1=$(mktemp)
     local ORFFILE2=$(mktemp)
     local ORFFILE3=$(mktemp)
     local ORFHEADERS2=$(mktemp)
     
     if [[ $threads != 1 ]]
     then
      sed --quiet ''"$ORFstart"','"$ORFend"'p;'"$(($ORFend + 1))"'q' $4 > $ORFFILE1
      sed --quiet ''"$ORFstart"','"$ORFend"'p;'"$(($ORFend + 1))"'q' $5 > $ORFHEADERS
     else
      cp -f $4 $ORFFILE1
      cp -f $5 $ORFHEADERS
     fi
     
      # Separate codons and cut to first start and stop codon
      local orf_num=1
      awk -F '' '{for(i=1; i<=NF; i+=3) {printf "%s%s ", $i,$(i+1)$(i+2);}; print ""}' $ORFFILE1 |
      if [ -z ${ignorestart+x} ]
       then
        awk -F $'\t' '{IGNORECASE = 1; if(match($0,"a[tu]g") > 0) print substr($0,match($0,"a[tu]g"));
       if(match($0,"a[tu]g") == 0) print ""}'
       else
        cat -
       fi |
      tee $ORFFILE3 |
      if [ ! -z ${fullprot+x} ]
      then
       awk -F $'\t' '{IGNORECASE = 1; if(match($0,"[tu]a[ag]|[tu]ga") > 0) print substr($0,1,match($0,"[tu]a[ag]|[tu]ga")+2);
      if(match($0,"[tu]a[ag]|[tu]ga") == 0) print ""}'
      else
       awk -F $'\t' '{IGNORECASE = 1; if(match($0,"[tu]a[ag]|[tu]ga") > 0) print substr($0,1,match($0,"[tu]a[ag]|[tu]ga")+2);
      if(match($0,"[tu]a[ag]|[tu]ga") == 0) print $0}'
      fi |
      if [ ! -z ${translate+x} ] && [ -z ${min_max_seq_length+x} ]
      then
       translate - |
       tr -d " [:lower:]" |
       if [ ! -z ${min_prot+x} ]
       then
        awk -v min_prot_length="$min_prot_length" '{if(match($0,"*|$") - 1 >= min_prot_length) print $0;
        if(match($0,"*|$") - 1 < min_prot_length) print ""}'
       else
        cat
       fi
      else
       tr -d " "
      fi > $ORFFILE2
      awk -F $'\t' -v orf_num="$orf_num" '{print $0"_orf"orf_num}' $ORFHEADERS > $ORFHEADERS2
      SWITCH=$ORFFILE1; ORFFILE1=$ORFFILE3; ORFFILE3=$SWITCH

      # Loop over other ORFs
      while [ $(grep --ignore-case --perl-regexp --count "a[tu]g" $ORFFILE1) -ne 0 ]
      do
      ((orf_num++))
      if [ $threads -gt 0 ] && [ ! -z ${max_orf_num+x} ] && [ $orf_num -gt $max_orf_num ]
      then
       break
      fi
      
       : > $ORFFILE3
       
       # Cut until first start and stop codon or until end of line
       awk -F $'\t' '{IGNORECASE = 1; if(match($0,"[tu]a[ag]|[tu]ga") > 0) print substr($0,match($0,"[tu]a[ag]|[tu]ga")+4);
       if(match($0,"[tu]a[ag]|[tu]ga") == 0) print ""}' $ORFFILE1 |
       if [ -z ${ignorestart+x} ]
       then
        awk -F $'\t' '{IGNORECASE = 1; if(match($0,"a[tu]g") > 0) print substr($0,match($0,"a[tu]g"));
       if(match($0,"a[tu]g") == 0) print ""}'
       else
        cat -
       fi |
       tee $ORFFILE3 |
       if [ ! -z ${fullprot+x} ]
      then
       awk -F $'\t' '{IGNORECASE = 1; if(match($0,"[tu]a[ag]|[tu]ga") > 0) print substr($0,1,match($0,"[tu]a[ag]|[tu]ga")+2);
      if(match($0,"[tu]a[ag]|[tu]ga") == 0) print ""}'
      else
       awk -F $'\t' '{IGNORECASE = 1; if(match($0,"[tu]a[ag]|[tu]ga") > 0) print substr($0,1,match($0,"[tu]a[ag]|[tu]ga")+2);
      if(match($0,"[tu]a[ag]|[tu]ga") == 0) print $0}'
      fi |
       if [ ! -z ${translate+x} ] && [ -z ${min_max_seq_length+x} ]
       then
        translate - |
        tr -d " [:lower:]" |
        if [ ! -z ${min_prot+x} ]
        then
         awk -v min_prot_length="$min_prot_length" '{if(match($0,"*|$") - 1 >= min_prot_length) print $0;
         if(match($0,"*|$") - 1 < min_prot_length) print ""}'
        else
         cat
        fi
       else
        tr -d " "
       fi >> $ORFFILE2
       awk -F $'\t' -v orf_num="$orf_num" '{print $0"_orf"orf_num}' $ORFHEADERS >> $ORFHEADERS2
       SWITCH=$ORFFILE1; ORFFILE1=$ORFFILE3; ORFFILE3=$SWITCH
       
      done
      
      cat $ORFHEADERS2 > HEADCORE$orf_core
      cat $ORFFILE2 > OUTCORE$orf_core
      
      # Cleanup
      rm --force $ORFFILE1 $ORFFILE2 $ORFFILE3 $ORFHEADERS $ORFHEADERS2
     }
     
     # Set Minimum protein length if minimum nucleotide size is set
     if [ ! -z ${min_max_seq_length+x} ] && [ ! -z ${translate+x} ]
     then
      min_prot=1
      min_prot_length=$((${min_max_seq_length[0]}/3))
     fi
     
     # Allocate sequences to requested threads
     seq_num=$(grep --perl-regexp --count "^>" $HEADERS)
     if [[ $seq_num -lt $threads ]]
     then
      threads=$seq_num
     fi
     
     # Setup start and end lines for dividing sequences
     BATCH=$(( seq_num / $threads ))
     remainder=$(( seq_num % $threads ))
     
     start=1
     end=()
     for ((core=0;core <= $(($threads - 1));core++))
     do
      if [[ ${#end[@]} != 0 ]]
      then
       start=(${start[@]} $((${end[$(($core - 1))]} + 1)))
      fi
      if [[ $core -lt $remainder ]]
      then
       end=(${end[@]} $((${start[$core]} + $BATCH)))
      else
       end=(${end[@]} $((${start[$core]} + $BATCH - 1)))
      fi
     done
     
     # Loop for function getting ORFs for multithreading
     HEADERS_TMP=$(mktemp)
     : > $OUTFILE
     : > $HEADERS_TMP

      for ((core=0;core <= $(($threads - 1));core++))
      do
       declare OUTCORE$core=$(mktemp)
       declare HEADCORE$core=$(mktemp)
       get_orfs ${start[$core]} ${end[$core]} $core $INFILE $HEADERS &
       pids[$core]=$!
      done     
      for pid in ${pids[*]}
      do
       wait $pid
      done
      for ((core=0;core <= $(($threads - 1));core++))
      do
       cat OUTCORE$core >> $OUTFILE
       cat HEADCORE$core >> $HEADERS_TMP
       rm --force OUTCORE$core HEADCORE$core
      done
     
     rm --force $HEADERS
     HEADERS=$HEADERS_TMP

     if [ ! -z ${verbose+x} ] && [ -z ${translate+x} ]
     then
      echo -n "ORF detection done: " >> $(readlink /proc/$$/fd/2)
      show_time $(($(date +%s) - time_start))
      echo "" >> $(readlink /proc/$$/fd/2)
     fi
     if [ ! -z ${verbose+x} ] && [ ! -z ${translate+x} ]
     then
      echo -n "ORF detection and translation done: " >> $(readlink /proc/$$/fd/2)
      show_time $(($(date +%s) - time_start))
      echo "" >> $(readlink /proc/$$/fd/2)
     fi
    fi
    
    # Minimum/Maximum length (nucleotie)
     if [ ! -z ${min_max_seq_length+x} ]
     then
     if [ ${min_max_seq_length[0]} -gt 0 ] || [ ${min_max_seq_length[1]} -gt 0 ]
     then
     SWITCH=$OUTFILE; OUTFILE=$INFILE; INFILE=$SWITCH
     if [ ${min_max_seq_length[1]} -eq 0 ]
     then
       awk -v min_seq_length="${min_max_seq_length[0]}" '{if(length($0) - 1 >= min_seq_length) print $0;
       else print ""}' $INFILE > $OUTFILE
     else
      awk -v min_seq_length="${min_max_seq_length[0]}" -v max_seq_length="${min_max_seq_length[1]}" '{if(length($0) - 1 >= min_seq_length && length($0) - 1 <= max_seq_length) print $0;
      else print ""}' $INFILE > $OUTFILE
     fi
     fi
     fi
    
    # Separate to codons and translate
    if [ ! -z ${translate+x} ] && ( [ -z ${orf+x} ] || [ ! -z ${min_max_seq_length+x} ] )
    then
     SWITCH=$OUTFILE; OUTFILE=$INFILE; INFILE=$SWITCH
     if [ ! -z ${verbose+x} ]
     then
      echo "Translate | frame(s) "${frame[@]} >> $(readlink /proc/$$/fd/2)
     fi
     if [ ! -z ${verbose+x} ] && [ $translate_table -ne 1 ]
     then
      echo "Translation code: "$translate_table >> $(readlink /proc/$$/fd/2)
     fi
     if [ ! -z ${verbose+x} ] && [ ! -z ${min_prot+x} ]
     then
      echo "Minimum protein length: "$min_prot_length >> $(readlink /proc/$$/fd/2)
     fi
     awk -F '' '{for(i=1; i<=NF; i+=3) {printf "%s%s ", $i,$(i+1)$(i+2);}; print ""}' $INFILE |
      translate - |
       tr -d " [:lower:]" |
       
       # remove if less than cutoff
       if [ ! -z ${min_prot+x} ]
       then
        awk -v min_prot_length="$min_prot_length" '{if(match($0,"*|$") - 1 >= min_prot_length) print $0;
        if(match($0,"*|$") - 1 < min_prot_length) print ""}'
       else
        cat
       fi > $OUTFILE
       if [ ! -z ${verbose+x} ]
       then
        echo -n "Translation done: " >> $(readlink /proc/$$/fd/2)
        show_time $(($(date +%s) - time_start))
        echo "" >> $(readlink /proc/$$/fd/2)
       fi
    fi
    
     # Combine headers and sequences
     SWITCH=$OUTFILE; OUTFILE=$INFILE; INFILE=$SWITCH
     if [ ! -z ${MW+x} ]; then detect_mol $INFILE; fi
     paste $HEADERS $INFILE |
     grep --perl-regexp --invert-match "\t$" > $OUTFILE
     
     # Get maxseq number of largest sequences from each input sequence
     if [ ! -z ${maxseq+x} ]
     then
      if [ ! -z ${verbose+x} ]; then echo "Extracting "$maxseq" longest sequence(s) for each input sequence" >> $(readlink /proc/$$/fd/2); fi
      SWITCH=$OUTFILE; OUTFILE=$INFILE; INFILE=$SWITCH
      awk -F $'\t' '{OFS="\t"}; {headers=$1}; {seq=$2}; {gsub(/_orf[0-9]+/,"",$1)}; {gsub(/_frame[0-9]+/,"",$1)}; {gsub("*","",$2)}; {print length($2),$1,headers,seq}' $INFILE |
      sort --parallel="$threads" --numeric-sort --reverse |
      sort --parallel="$threads" --unique --key=2,2 |
      cut --fields=3,4 > $OUTFILE
     fi
     
     if [ ! -z ${unique+x} ]
     then
      SWITCH=$OUTFILE; OUTFILE=$INFILE; INFILE=$SWITCH
      sort --ignore-case --parallel="$threads" --unique --key=2 $INFILE > $OUTFILE
      if [ ! -z ${verbose+x} ]
      then
       echo -n "Remove duplicates done: " >> $(readlink /proc/$$/fd/2)
       show_time $(($(date +%s) - time_start))
      fi
     fi
          
     # Sort by name
     if [ ! -z ${name_sort+x} ]
     then
     if [ ! -z ${verbose+x} ]
     then
      echo "Sort by name" >> $(readlink /proc/$$/fd/2)
     fi
      SWITCH=$OUTFILE; OUTFILE=$INFILE; INFILE=$SWITCH
      if [ ! -z ${reverse_sort+x} ]
      then
      if [ ! -z ${verbose+x} ]
      then
       echo "Sort in reverse order" >> $(readlink /proc/$$/fd/2)
      fi
       sort --parallel="$threads" --reverse --field-separator=$'\t' --key=1 $INFILE > $OUTFILE
      else
       sort --parallel="$threads" --field-separator=$'\t' --key=1 $INFILE > $OUTFILE
      fi
      if [ ! -z ${verbose+x} ]
      then
       echo -n "Name sort done: " >> $(readlink /proc/$$/fd/2)
       show_time $(($(date +%s) - time_start))
       echo "" >> $(readlink /proc/$$/fd/2)
      fi
     fi
    
    # Sort by sequence length
     if [ ! -z ${length_sort+x} ]
     then
      if [ ! -z ${verbose+x} ]
      then
       echo "Sort by length" >> $(readlink /proc/$$/fd/2)
      fi
      SWITCH=$OUTFILE; OUTFILE=$INFILE; INFILE=$SWITCH    
      awk -F '\t' '{OFS="\t"; print length($2),$0}' $INFILE |
      if [ ! -z ${reverse_sort+x} ]
      then
      if [ ! -z ${verbose+x} ]
      then
       echo "Sort in reverse order" >> $(readlink /proc/$$/fd/2)
      fi
       sort --parallel="$threads" --numeric-sort --reverse
      else
       sort --parallel="$threads" --numeric-sort
      fi |
      cut --fields=2,3 > $OUTFILE
      if [ ! -z ${verbose+x} ]
      then
       echo -n "Length sort done: " >> $(readlink /proc/$$/fd/2)
       show_time $(($(date +%s) - time_start))
       echo "" >> $(readlink /proc/$$/fd/2)
      fi
     fi
     
     # GC content
     if [ ! -z ${percent_GC+x} ]
     then
     if [ ! -z ${verbose+x} ]
     then
      echo "Percent GC" >> $(readlink /proc/$$/fd/2)
     fi
     SWITCH=$OUTFILE; OUTFILE=$INFILE; INFILE=$SWITCH
      paste <(cut --fields=1 $INFILE | tr -d ">") <(cut --fields=2 $INFILE | awk '{var=length($0);gsub("[AaTt]","",$0);print length($0)/var*100}')
      if [ ! -z ${verbose+x} ]
      then
       echo -n "GC fraction done: " >> $(readlink /proc/$$/fd/2)
       show_time $(($(date +%s) - time_start))
       echo "" >> $(readlink /proc/$$/fd/2)
      fi
      rm --force $INFILE $OUTFILE $HEADERS
      exit 0
     fi
     
     # Calculate molucular weight
    if [ ! -z ${MW+x} ]
    then
    if [ ! -z ${verbose+x} ]; then echo "Calculating molecular weight" >> $(readlink /proc/$$/fd/2); fi
     SWITCH=$OUTFILE; OUTFILE=$INFILE; INFILE=$SWITCH
     if [[ $MOLECULE == "DNA" ]] || [[ $MOLECULE = "RNA" ]]
     then
      paste <(cut --fields=1 $INFILE | tr -d ">") <(cut --fields=2 $INFILE | calc_MW 1 -) <(cut --fields=2 $INFILE | calc_MW 2 -)
     elif [[ $MOLECULE == "PROTEIN" ]]
     then
      paste <(cut --fields=1 $INFILE | tr -d ">") <(cut --fields=2 $INFILE | calc_MW 1)
     else
      echo "Error detecting molecule" >> $(readlink /proc/$$/fd/2)
      exit 1
     fi
     if [ ! -z ${verbose+x} ]
      then
       echo -n "Molecular weight done: " >> $(readlink /proc/$$/fd/2)
       show_time $(($(date +%s) - time_start))
       echo "" >> $(readlink /proc/$$/fd/2)
      fi
      rm --force $INFILE $OUTFILE $HEADERS
      exit 0
    fi
    
     # Detect restriction sites
     if [ ! -z ${renz+x} ] && [[ $MOLECULE != "PROTEIN" ]]
     then
     if [ ! -z ${verbose+x} ]; then echo "Detecting restriction sites" >> $(readlink /proc/$$/fd/2); fi
      SWITCH=$OUTFILE; OUTFILE=$INFILE; INFILE=$SWITCH
      paste <(cut --fields=1 $INFILE | tr -d ">") <(res_enz $INFILE ${min_max_re[0]=0} ${min_max_re[1]=0} ${min_max_re[2]=0} ${min_max_re[3]=0})
      if [ ! -z ${verbose+x} ]
      then
       echo -n "Restriction site detection done: " >> $(readlink /proc/$$/fd/2)
       show_time $(($(date +%s) - time_start))
       echo "" >> $(readlink /proc/$$/fd/2)
      fi
      rm --force $INFILE $OUTFILE $HEADERS
      exit 0
     fi
     
     # Separate sequences into files
     if [ ! -z ${separate+x} ]
     then
     echo "Separating sequences into files..." >> $(readlink /proc/$$/fd/2)
      if [ ! -d $separate ]
      then
       mkdir -p $separate
      fi
      for ((k=1;k<=$(cat $OUTFILE | wc -l);k++))
      do
       cut --fields=1 $OUTFILE | sed --quiet ''"$k"','"$k"'p;'"$(($k + 1))"'q' > $separate/$k.fasta
       cut --fields=2 $OUTFILE | sed --quiet ''"$k"','"$k"'p;'"$(($k + 1))"'q' >> $separate/$k.fasta
      done
      if [ ! -z ${verbose+x} ]
      then
       echo -en "\nSequence separation done: " >> $(readlink /proc/$$/fd/2)
       show_time $(($(date +%s) - time_start))
      fi
      rm --force $INFILE $OUTFILE $HEADERS
      exit 0
     fi
     
     # Convert tabbed to FASTA
     SWITCH=$OUTFILE; OUTFILE=$INFILE; INFILE=$SWITCH
     cat $INFILE |
     tr "\t" "\n" > $OUTFILE
     
    # Output to file or stdout
    if [ ! -z ${out+x} ]
    then
     if [ ! -z ${verbose+x} ]
     then
      echo $(basename $1)" ---> "$output_file >> $(readlink /proc/$$/fd/2)
     fi
     cp --force $OUTFILE $output_file
    else
     if [ ! -z ${inplace+x} ]
     then
      cp --force $OUTFILE $FILE
     else
      cat $OUTFILE
     fi
    fi
    
    # Cleanup temp files
    rm --force $INFILE $OUTFILE $HEADERS
    if [ ! -z ${stdin+x} ]
    then
     rm --force $FILE
    fi
    
    if [ ! -z ${verbose+x} ]
    then
     echo -ne "\nfastakit done: " >> $(readlink /proc/$$/fd/2)
     show_time $(($(date +%s) - time_start)) >> $(readlink /proc/$$/fd/2)
    fi
